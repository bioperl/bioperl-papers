\documentclass[12pt]{article}
% $Id: bioperl-article.tex,v 1.37 2002-07-27 23:54:19 jason Exp $
% $Log: not supported by cvs2svn $
% Revision 1.36  2002/07/25 22:11:29  jason
% Brian O's updates
%
% Revision 1.35  2002/07/25 20:06:56  jason
% advanced advanced -> advanced, fixed Brian's zip code
%
% Revision 1.34  2002/07/25 18:34:53  jason
% revisions incorporating Lincoln and Chad's changes
%
% Revision 1.33  2002/07/16 19:18:36  jason
% incorporate some changes in response to reviewers - consider fixing the figures better
%
% Revision 1.32  2002/05/04 20:32:43  jason
% submitted version
%
% Revision 1.31  2002/04/22 17:14:53  jason
% spelling mistakes corrected
%
% Revision 1.30  2002/04/22 17:02:57  jason
% changes to let figure2 be submitted separately and include a little more clarity in discussion
%
% Revision 1.29  2002/04/19 03:56:04  lapp
% Mostly typographical corrections. Some little polishing of the discussion
% section about others' failures.
%
% Revision 1.28  2002/04/16 20:36:10  jason
% remove personal communication
%
% Revision 1.27  2002/04/16 20:32:11  jason
% added figure 2 back in and simplified caption, also fixed a couple of typos and a added some flow to the discussion
%
% Revision 1.26  2002/04/16 15:06:38  jason
% rough changes to discussion -- need a rework
%
% Revision 1.25  2002/04/12 18:39:38  lstein
% Edits following conference call between Jason, Lincoln and Hilmar.
%
% Revision 1.24  2002/04/12 05:37:28  lapp
% Corrected a few more typos and errors. Rest for tomorrow's phone
% conference.
%
% Revision 1.23  2002/04/12 03:12:09  jason
% caption text fixes and fixed small bug in the figure 2 code
%
% Revision 1.22  2002/04/11 15:53:05  jason
% small editorial changes and tense correction
%
% Revision 1.21  2002/04/10 03:31:13  jason
% spelling changes, updated title
%
% Revision 1.20  2002/04/09 20:38:30  jason
% Added reference to the figures and Table 1 -- these appear at the end of my PDF document when using pdflatex
%
% Revision 1.19  2002/04/09 19:44:34  lstein
% Minor grammar and typographical fixes from lincoln
%
% Revision 1.18  2002/04/07 20:47:05  jason
% merged in most of Hilmar's comments with some edits.  I think 3 main things are left to polish: Abstract, Conclusion, and Interoperability
%
% Revision 1.17  2002/04/07 08:30:41  heikki
% minor fixes
%
% Revision 1.16  2002/04/06 19:07:08  lapp
% Spelled out GNF.
%
% Revision 1.15  2002/04/05 23:15:32  jason
% some changes to format towards GR - a few sentance reworks and transitions - cut it down to 5 main topics, pages for weblinks and each figure with captions
%
% Revision 1.14  2002/04/05 17:19:02  jason
% grammatical changes
%
% Revision 1.13  2002/04/02 00:07:13  jason
% rework, with Mark's comments - still need to add Matt's suggestions
%
% Revision 1.12  2002/03/25 14:17:28  jason
% small TeX bugs
%
% Revision 1.11  2002/03/24 20:49:13  jason
% reworking abstract, removed redundancy and greatly simplified the interoperability section.  Need to condense to probably 4-5 main sections
%
% Revision 1.10  2002/03/21 21:50:04  jason
% reworked abstract for GR and moved examples around.  Reworked abstract for GR and moved examples around.  Added statistics about tests and number of modulesTable for Modules rather than list.
%
% Revision 1.9  2002/03/19 10:58:47  heikki
% fixing examples, lot's of typos in the docs, minor changes
%
% Revision 1.8  2002/03/13 21:21:08  jason
% 3rd draft - with Lincoln's changes
%
% Revision 1.7  2002/03/04 22:18:09  jason
% Some reworking of text, placeholders for expansion on the major 
% theme of open-source developmentmore references and testing out 
% the lstlisting for code section, lines
% are not wrapping nicely though in 2-column mode with the code,
% Author list still incomplete and need to move acknowledgements
% around some more
%

\usepackage {pxfonts,listings,hyperref,url,genomeres,layouts,
	    pstricks, epsfig,graphicx,keyval,fancyhdr,
	     setspace,fullpage }

\begin{document}

\doublespacing

\title{The Bioperl Toolkit: Perl modules for the life sciences}

% Jason E Stajich 
% David Block
% Kris Boulez
% Steven E Brenner
% Steve Chervitz
% Chris Dagdigian
% Georg Fuellen
% James G R Gilbert
% Ian Korf
% Hilmar Lapp
% Heikki Levaslaiho
% Chad Matsalla
% Chris J Mungall
% Brian Osborne
% Matthew Pocock
% Peter Schattner
% Martin Senger
% Lincoln D Stein
% Elia Stupka
% Mark D Wilkinson
% Ewan Birney

\author{Jason E Stajich$^{1}$$^*$ 
\and David Block$^{2}$ 
\and Kris Boulez$^{3}$
\and Steven E Brenner$^{4}$ 
\and Stephen A Chervitz$^{5}$ 
\and Chris Dagdigian$^{6}$ 
\and Georg Fuellen$^{7}$ 
\and James G R Gilbert$^{8}$
\and Ian Korf$^{9}$ 
\and Hilmar Lapp$^{10}$ 
\and Heikki Lehv\"{a}slaiho$^{11}$ 
\and Chad Matsalla$^{12}$ 
\and Chris J Mungall$^{13}$ 
\and Brian I Osborne$^{14}$ 
\and Matthew R Pocock$^8$ 
\and Peter Schattner$^{15}$ 
\and Martin Senger$^{11}$ 
\and Lincoln D Stein$^{16}$ 
\and Elia Stupka$^{17}$ 
\and Mark D Wilkinson$^2$ 
\and Ewan Birney$^{11}$ \\}

\maketitle

\begin{abstract}

The Bioperl project is an international open source collaboration of
biologists, bioinformaticians, and computer scientists that has
evolved over the last 7 years into the most comprehensive library of
Perl modules available for managing and manipulating life science
information.  Bioperl provides an easy-to-use, stable, and consistent
programming interface for bioinformatics application programmers.  The
Bioperl modules have been successfully and repeatedly used to reduce
otherwise complex tasks to only a few lines of code.  The Bioperl
object model has been proven to be flexible enough to support
enterprise-level applications such as EnsEMBL while maintaining an
easy learning curve for novice Perl programmers.  Bioperl is capable
of executing analyses and processing results from programs such as
BLAST, ClustalW, or the EMBOSS suite.  Interoperation with modules
written in Python and Java is supported through the evolving BioCORBA
bridge.  Bioperl provides access to data stores such as Genbank
and Swissprot via a flexible series of sequence input/output modules,
and to the emerging common sequence data storage format of the Open
Bioinformatics Database Access project.

This paper describes the overall architecture of the toolkit, the
problem domains which it addresses, and gives specific examples of how
the toolkit can be used to solve common life sciences problems.  We
conclude with a discussion of how the open source nature of the
project has contributed to the development effort.

Bioperl is available as open source software free of charge and
licensed under the Perl Artistic License
(\url{http://www.perl.com/pub/a/language/misc/Artistic.html}).  It is
available for download at \url{http://www.bioperl.org}.  
Support inquiries should be addressed to \url{bioperl-l@bioperl.org}.

\textbf{Keywords:} Bioinformatics Software Perl
\par \noindent $^*$To whom correspondence should be addressed. \\
$^1$ \small{\textit{University Program in Genetics, Duke University,
Durham, NC 27710 USA}} \\
$^2$ \small{\textit{National Research Council of Canada, Plant
Biotechnology Institute, 110 Gymansium Pl, Saskatoon, SK S7N OW9 Canada}} \\
$^3$ \small{\textit{AlgoNomics, Gent, B 9052 Belgium}} \\
$^4$ \small{\textit{Department of Plant \& Molecular Biology,
111 Koshland Hall, University of California, Berkeley, CA 94720-3102 USA}} \\
$^5$ \small{\textit{Affymetrix, Inc., 6550 Vallejo St., Suite 100,
Emeryville, CA 94608 USA}} \\
$^6$ \small{\textit{Open Bioinformatics Foundation, Somerville, MA
02144 USA}} \\
$^7$ \small{\textit{Integrated Functional Genomics, IZKF, University
Hospital Muenster, 48149 Muenster Germany}} \\
$^8$ \small{\textit{The Welcome Trust Sanger Institute, Welcome Trust
Genome Campus, Hinxton, Cambridge, CB10 1SA UK}} \\
$^9$ \small{\textit{Department of Computer Science, Washington
University, One Brookings Drive, St. Louis, MO 63130 USA}} \\
$^{10}$ \small{\textit{Genomics Institute of the Novartis Research
Foundation (GNF), San Diego, CA 92121 USA}} \\
$^{11}$ \small{\textit{European Bioinformatics Institute, Welcome Trust
Genome Campus, Hinxton, Cambridge CB10 1SD UK}} \\
$^{12}$ \small{\textit{Agriculture \& Agri-Food Canada, Saskatoon
Research Centre, Saskatoon SK, S7N 0X2 Canada }} \\
$^{13}$ \small{\textit{Berkeley Drosophila Genome Project, University of California, Berkeley CA 94720 USA}} \\
$^{14}$ \small{\textit{Cogina, 117 E. 55th St, NYC NY, 10022 USA}} \\
$^{15}$ \small{\textit{Center for Biomolecular Science \& Engineering,
227 Sinsheimer Labs, University of California, 1156 High Street, Santa Cruz, CA 95064 USA}} \\
$^{16}$ \small{\textit{Cold Spring Harbor Laboratory, 1 Bungtown Rd,
Cold Spring Harbor, NY 11724 USA}}\\
$^{17}$ \small{\textit{Institute of Molecular and Cell Biology, 117609
Singapore}}\\

\end{abstract}

\section{Introduction}

Computational analysis is an integral part of modern biological
research.  Numerous computer software tools exist to perform data
analyses, but it is not simple to automatically combine data and
results from multiple sources without the use of computer software
designed to read and write data specific to the biological domain.
The day-to-day work in a typical bioinformatics lab consists largely
of writing program logic to achieve this data integration.

Perl is one of the most widely used programming languages for these
tasks and is commonly thought of as the language most easily grasped
by newcomers to the field.  Perl has been extremely successful for
connecting software applications together into sequence analysis
pipelines, converting file formats, and extracting information from
the output of analysis programs and other text files.

Much of the Perl software in bioinformatics is specific to a
particular lab or institution and is written for immediate utility
rather than reusability.  This results in considerable inefficiency,
as the same software is rewritten multiple times.  The Bioperl toolkit
brings together reusable Perl modules containing generalized routines
specific to life science information.  A primary motivation behind
writing the toolkit is the authors' desire to focus energies on a
solution whose components can be shared rather than duplicating
effort.  In our minds, once a routine is written for parsing and
interpreting sequence from EMBL and Genbank format sequence files no
one should ever have to write this routine again.  In this spirit we
chose to make our code freely available under an open source license
\cite{open-source-ref} so that others could extend routines already in
the Bioperl library and contribute their own routines as well.  Just
as the Human Genome Project was facilitated by public sharing of data,
so has the open nature of the Bioperl project reduced the time for
solutions and new tools to reach the community \cite{waterston}.

To be adopted by the community our software has to be user friendly.
To that end Bioperl provides extensive documentation of all the
routines in each module, a graphical diagram of the objects in the
toolkit, and a set of tutorials that lead the reader through the
solutions to common tasks.  Additionally we have created a simplified
interface to Bioperl that provides entry-level access to the toolkit.
The goal of Bioperl is to help a user focus on her specific problem at
hand, such as the logic needed to filter hits in a BLAST \cite{blast}
report by certain criteria, rather than on the actual mechanics of
parsing that BLAST report.

\section{Software Development Methodology}

The Bioperl project began in 1995 \cite{chervitz-bits} at a time when
there were few programming toolkits for manipulating biological data
or results from sequence analysis programs.  Although Perl had already
gained widespread popularity in the bioinformatics community for its
efficient support of text processing and pattern matching tasks, there
were in fact no biological toolkits available in this language.

The project grew out of the following observations.  
\begin{itemize}

\item First, even though file formats of different analysis programs
are different, the information they represent is the same.  For
example, a pair-wise alignment is always between two sequences and has
common properties such as length, score, fraction of identities, start
and end of the aligned sequences, and so forth.

\item Second, the number of data structures needed to represent
information flow is limited, and common to most applications, such as
sequences, annotation, features, and alignments.  This permits a 
small set of modules to be reused for a variety of purposes.

\item Third, a set of operations is commonly performed on these data
structures.  These include reading and writing information to a file,
querying a sequence for its features, and translating a coding
sequence into protein.

\end{itemize}

This scenario naturally lends itself to the principle of
object-oriented programming, which Perl emulates with modules.

Object-oriented programming is the practice of grouping related tasks
together into logical and broadly applicable components.  For example,
a DNA Sequence component could contain methods to retrieve the
sequence's accession number, reverse complement the DNA, or translate
it into a protein sequence.  Object-oriented programming methodology
allows accurate modeling of the problem domain leading to more
robust, valid, and reusable code. Instead of attacking a problem by
brute force the problem is analysed and models are constructed to
represent the entities in the problem and solution domains. The
entities are represented in code through the use of Perl modules and,
where appropriate, form elements in an inheritance hierarchy.  The use
of inheritance and polymorphism in Bioperl implements the well
established principles of information hiding, modularity, and module
cohesion \cite{tremblay}.

We designed Bioperl using object-oriented methodology so as to create
clean, generic and reusable modules to represent data structures and
operations common to the life sciences.  By separating the components
into logical groups, such as sequences, alignments, and databases, we
have been able to add features to a specific module without
necessarily affecting the rest of the toolkit library.  This
separation is a key aspect of object-oriented programming and permits
us to produce generic components with a stable interface for the
programmer (the so-called API).

At present the components and operations in Bioperl center around
biological sequence analysis and annotation.  In the last year the
project has expanded to address new areas including phylogenetics,
maps, protein structure, and bibliographic references.  The project
has over 300 modules and comprises more than 160,000 lines of code and
embedded documentation.  The Perl modules, illustrated in Table
\ref{tab:modules}, are organized by logical names so that, for
example, the Bio::Search hierarchy contains modules related to
database searches and Bio::Graphics contains modules that are related
to drawing (Figure 1).  The Bio::Perl module itself is a simplified
API that provides access to the most-commonly used Bioperl functions.

When designing Bioperl objects we sought to provide a
programming interface that is very easy to use but that at the same
time could be easily extended in its capabilities and behavior through
code reuse.  Using an object-oriented paradigm we followed certain
design principles.

\begin{itemize}

\item Separate the interface from the implementation.  The key
information about a component is the method names and their list of
accepted arguments.  Similar in concept to interfaces in Java, we
built interfaces as collections of methods which describe the expected
behavior of a module, but do not do any of the work.  Child modules
implement the interfaces, providing specializations of their parents
to perform specific tasks.  To help distinguish implementation modules
from interface definitions we used a capital 'I' appended to the
object name.  This principle is based on the well-established
methodology of specifying a given module's Abstract Data Type by
defining how a given module will behave without specifying the
mechanism by which it achieves this end.

For example, Bio::SeqFeatureI describes the "contract" for all modules
which are features on sequences.  This includes methods for
start, end, strand, and access to comments and other attributes via tag/value
pairs.  All modules in the Bio::SeqFeature hierarchy implement this
interface (Figure 2).  The power of this design is that operations
which expect a Bio::SeqFeatureI, such as operations in the
Bio::Graphics modules, can operate on anything which implements the
Bio::SeqFeatureI interface.  In this manner, sequence annotation that
is retrieved from a DAS server \cite{das}, a local file, or a database
server can all be drawn as an image with the same methods in the
Bio::Graphics modules.

\item Generalize common routines into a single module providing a base
framework for the respective operations.  As an example we centralized
the basic Input/Output (IO) operations into an IO object, called
Bio::Root::IO.  Because all modules that need IO data access use
operations from the IO module, these operations are implemented across
the entire package in a consistent way.  This design choice also
provides a single location for applying improvements to the shared
methods.  

\item Employ the Factory and Strategy patterns \cite{gangoffour} as
much as possible. A Strategy pattern defines one or more operations a
particular implementation must support.  As an example, Bio::SeqIO
defines that implementations support the operation
\textit{next\_seq()}, returning the next sequence in the stream as a
Bio::PrimarySeqI compliant object.  Various parsers for the different
sequence formats implement this method, thereby providing one
consistent interface to sequence streams irregardless of the format.
The Factory pattern is a general way to write a module which will
create specific modules of a related type.  It can serve as an
aggregator for a set of modules which implement the same Strategy.
For example, the Bio::SeqIO acts as a Factory which produces specific
sequence file parsers for different sequence formats.  When the user
asks Bio::SeqIO to parse a particular sequence file, Bio::SeqIO
determines the correct parser to instantiate and invoke, thereby
shielding application code from the technical details of the sequence
file format and the Bio::SeqIO object hierarchy. Application code can
be written generally to handle sequence input without worrying about
whether it is processing a sequence file in GenBank, EMBL, SwissProt,
or BSML format, or indeed whether the sequence data is local, or being
retrieved dynamically from a remote database via the Internet.
\end{itemize}


Bioperl is written purely in Perl and requires at least version 5.005
of the Perl interpreter (the current stable version of Perl as of the
time of writing is 5.8.0).  The toolkit has been validated for
cross-platform compatibility on most UNIX and UNIX-like operating
systems.  In addition, Bioperl has been tested and runs on Macintosh
OS X and Microsoft Windows operating systems.  

Since the Bioperl toolkit depends on the Perl interpreter, there are a
number of rare cases where its behavior is not consistent across
different versions of Perl or between versions of Perl on certain
operating systems.  Descriptions of these version-specific problems
and their solutions are available from the Bioperl website.

In addition to pure Perl solutions to bioinformatics problems, Bioperl
can take advantage of external data analysis packages.  Bioperl is
capable of parsing the output from a variety of programs including
BLAST (both NCBI and WUBLAST \cite{wublast} versions), HMMer
\cite{hmmer}, ClustalW \cite{clustalw}, T-Coffee \cite{tcoffee},
Phylip \cite{phylip}, many EMBOSS \cite{emboss} programs, Genscan
\cite{genscan}, and 18 others.  In addition, it can launch remote
analyses using the EMBOSS suite, NCBI BLAST, and the multiple sequence
alignment programs ClustalW and T-Coffee.  In some cases, when an
external package is not available, Bioperl will fall back to using a
slower method, either by emulating the package in pure Perl or by
invoking a network-based analysis service such as the NCBI BLAST
analysis queue.  Additional work is in progress to incorporate into
the project access to remote analysis services at the European
Bioinformatics Institute (EBI)
(Novella: \url{http://industry.ebi.ac.uk/novella}) and Pasteur Institute
(Pise: \url{http://bioweb.pasteur.fr}).

In order for us to produce uniform software code, we established
coding guidelines that are extensions of widely accepted
object-oriented programming style.  All modules were required to meet
minimal standards before release.  These standards include a complete
set of regression tests, well formed embedded documentation for each
method, and a concise example code in the SYNOPSIS section of each
module's documentation.  We use the Perl embedded documentation format
(called POD, or Plain Old Documentation) to interleave documentation and
the source code.  This documentation can be converted to text, TeX, or
HTML.  We have used the Pdoc (\url{http://pdoc.sourceforge.net}) tool to
generate colored and hyperlinked documentation in HTML for easy
online browsing available at \url{http://doc.bioperl.org}.

Our development process usually starts when someone presents an idea
for a needed tool on our mailing list.  Typically a prototype or
example code is posted and we discuss ideas for implementation and
common scenarios for where the functionality is needed.  We then
develop an interface for the proposed module which describes the basic
routines the module will implement.  Whenever a module is written we
require a set of regression tests to be written for it.  This is
designed to ensure that the module satisfies its declared interface
and can be easily tested later on when other modules which may
interact with it have been updated.  Bioperl 1.0 has over 3000 such
tests which were passed on multiple platforms before the toolkit was
declared ready for release.  Finally, all Bioperl code is subject to
ongoing code review by and with the core developer group.  This
methodology is derived in large part from the software development
strategy called "Extreme Programming" \cite{xprogramming}.  This
process is highly iterative and modules are often revisited and improved
depending on the needs of the developer.  We attempt to always
maintain a backwards compatibility so that code that depend on an
earlier version of the module will continue to work.    

To support multiple developers in different time zones and
institutions, the entire Bioperl source code is hosted by the Open
Bioinformatics Foundation (OBF) (\url{http://www.open-bio.org}) on a
server where our code and documentation is shared among developers and
interested users.  Information on how to obtain the source directly
from our server is available at the project website
\url{http://www.bioperl.org/} and the source code server at
\url{http://cvs.open-bio.org/}.

\section{Results}

Bioperl has over 20 active developers led by a core of 5 primary developers
who ensure that standards are met, prepare code releases, and set the
vision for the project.  At the time of publication the mailing lists
for the project include 1300 subscribers and an average of 10,000
unique visitors to our website each month.  The project has been used
in a variety of endeavors including genome sequencing, annotation,
sequence variation elucidation, disease gene discovery, and
comparative genomics.  An example using Bioperl modules to complete
the task of retrieving sequences from a remote database is
shown in Figure 3, and an example of parsing a BLAST report can be
seen in Figure 4.

By far the most advanced use of the Bioperl toolkit has come through
the EnsEMBL \cite{ensembl-nar} project.  The basic sequence handling,
file format parsing, and sequence features for annotation model have
been used as building blocks for automatically annotating the
\textit{Danio rerio}, \textit{Drosophila melanogastor},
\textit{Takifugu rubripes}, \textit{Homo sapiens}, \textit{Anopheles
gambiae}, and \textit{Mus musculus} genomes
(\url{http://www.ensembl.org}).

Additionally the Genquire \cite{genquire} annotation package is built
on top of the Bioperl object model and stores sequence and annotation
data in a relational database.  The interactive sequence rendering
capabilities are partitioned into a specific Bioperl package called
bioperl-gui.

The Generic Model Organism Browser (GBrowse) \cite{gmod}, Distributed
Annotation System Perl (DAS) server \cite{das}, and TFBS \cite{tfbs}
all use the Bioperl object model to describe sequences and Bioperl
tools to complete analyses.  The GBrowse system is a web interface to
databases of features for a genome project.  The DAS system provides
researchers a means to locally annotate sequences and publish the
annotations to the community via the DAS XML protocol.  TFBS provides
a Perl implementation of objects for DNA sequence pattern
representation by matrix profiles, with associated methods for
searching the sequences for the occurrence of patterns, pattern
storage, and generation of new patterns. The implementation uses
Bioperl sequence, alignment, sequence features, and feature pair
objects.

\subsection{Interoperability}

Sometimes the best solution for a bioinformatics problem is a hybrid
of multiple tools.  Providing interoperability between languages
allows a programmer using the toolkit to build components using work
done in other languages and projects.  These tools, written in
different programming languages such as C, Java, and Python, can be
used within a Perl program simply by invoking them (a process often
called ``shelling out'').  In some situations these tools require that
data be available in a certain format or within a certain database.
Bioperl provides software layers which can, for example, populate a
database with sequence information which can be accessed and used to
generate an interactive graphical interface provided by the Biojava
toolkit.  In other cases, Bioperl is used to create files in a format
recognized by other programs so that they can perform their analyses.

Bioperl also supports a number of Extensible Markup Language (XML)
standard data exchange formats accepted in the Bioinformatics
community.  Previous work has outlined scenarios where XML has been
useful in a biological context \cite{xmlbioinformatics}.  XML
standards supported by Bioperl include the sequence markup formats
Bioinformatics Sequence Markup Language (BSML;
\url{http://www.bsml.org}) and Berkeley Drosophila Genome Project's
(\url{http://www.fruitfly.org}) Genome Annotation Markup Elements
(GAME; \url{http://www.bioxml.org/dtds/index.html}), NCBI BLAST XML
for BLAST reports, and the bibliographic standards Medline XML
provided by the European Bioinformatics Institute's Bibliographic
Query Service (BQS; \url{http://industry.ebi.ac.uk/openBQS/}) and
Entrez Pubmed XML format \cite{entrez}.  By supporting these XML-based
formats, programs using Bioperl are able to process data from a
growing number of data sources that have adopted them as their standard.
Furthermore, the extensible nature of XML allow new features to be added
to the data formats without breaking existing parsers and code.

Software can interoperate not only through the invocation of external
programs, but also through invoking methods on remote components
possibly written in a different programming language from the calling
component.  Such a mechanism constitutes the tightest integration of
re-usable software components in a language-independent way.  The
Common Object Request Broker Architecture (CORBA) \cite{corba}
provides an architecture for enabling this technology.  This
technology has been applied to biological data at the EBI in their
Radiation Hybrid \cite{rhdb} and EMBL Nucleotide Databases
\cite{embl-corba}.  CORBA implementations are available from
commercial vendors (e.g., Inprise's VisiBroker, IONA's ORBacus) as
well as from open source projects (e.g. ORBit, MICO).  Bioperl is
compliant with the BioCORBA project (\url{http://www.biocorba.org}),
one of the proposed standards for CORBA components for biological
processes.  BioCORBA is also supported by the Biojava
(\url{http://www.biojava.org}) and Biopython
(\url{http://www.biopython.org}) projects.  The standard is under
consideration for adoption by the Object Management Group's Life
Science Research group (\url{http://lsr.ebi.ac.uk}) and is included in
the proposed Open Bioinformatics Database Access (OBDA;
\url{http://obda.open-bio.org}) standard for sequence data access.
Bioperl's support for BioCORBA allows applications written on top of
Bioperl to interact transparently with remote BioCORBA servers to
perform operations as diverse as protein domain analysis and
bibliographic retrieval without knowing any of the details of the
CORBA protocol.

Lastly, Bioperl fully supports the recent Open Bioinformatics Database
Access initiative (OBDA), a language-independent relational database
schema for the storage and retrieval of Genbank/EMBL entry-based
sequences.  By supporting this common schema, sequence objects that
are created and maintained by Bioperl can be accessed and manipulated
by OBDA-compliant programs written in Java, Python, Ruby or C.  This
provides a level of read/write cross-platform data compatibility
unmatched by any other sequence database project, and enables
extensive enterprise-level application development.

\section{Discussion}

Open source development has proven to be a valuable and productive
mechanism for creation of the toolkit.  No single individual owns the
project, rather it is owned by the community of contributors.  The
community approach prevents the death of a project due to loss of
interest by the sole developer and does not permit project stagnation
in the confines of a single laboratory where a single individual or
group is responsible for the continued vitality of a project.  The
original Bioperl project team has been completely replaced over the
last 7 years as members leave the project and new contributors join,
however the project aims have remained focused while the
functionality has continued to expand.

Throughout the development process we learned a great deal about
appropriate software practices for a diverse group of contributors.
Our programming methodology, which include defining use cases for
our software, establishing a comprehensive regression test suite, and
utilizing code reviews or audits of contributed source code, helped
the community develop code that is compatible and consistent.  The
principles of good design and good documentation have made it easier
for new developers to join the project.

A number of previous collaborative projects to develop comprehensive
libraries for the life sciences have produced unsatisfactory results,
or been aborted prior to fruition.  We believe that in many of these
cases, ongoing development was stymied by a lack of commitment to open
source principles.  For example, BioWidgets, an early attempt to
create a Java-based biological toolkit, did not adopt an open source
methodology at its inception.  This left it open to intellectual
property disputes, and ultimately the project dissolved as early
contributors withdrew their software from the project (N. Goodman,
personal communication).  In contrast, none of the software placed in
Bioperl can be withdrawn from the project because it has been
explicitly donated to the community using a license that expressly
permits copying and modification.

Another example of a non-open source project that has failed to live
up to its potential is the NCBI toolkit
(\url{ftp://ftp.ncbi.nih.gov/toolbox/ncbi_tools/}), a powerful and
highly functional C-language based toolkit.  Despite its quality, the
toolkit has failed to achieve widespread usage because of acknowledged
deficiencies in its documentation and a development process that is
closed.  By limiting the development process to NCBI personnel, the
toolkit has evolved to work best within the NCBI environment and to
address NCBI-specific operating procedures.  Outside of the NCBI, the
toolkit is used to run BLAST while other functionality lies fallow.
In contrast, Bioperl has a large and active userbase because of
extensive interaction between the developers and the users of the
library.  We allow users to contribute bug fixes and documentation
improvements directly to the project, thereby keeping the project
relevant to their needs.

We feel that much of the success of the Bioperl toolkit can be
attributed to the open source nature of the project which has allowed
a diverse group of individuals to participate in a collaborative effort.
We have successfully encouraged users of the toolkit to assist in the
development by contributing bug fixes, documentation enhancements, and
new functionality for the benefit of all users.  Contributors are part
of academic, governmental, non-profit, pharmaceutical, and
commercial bioinformatics groups on every continent.  This collaboration and
the guiding principle to get working products written in an extensible
manner have made Bioperl an excellent platform for Perl bioinformatics
software development.  The open sharing and discussion of ideas that
embodies the scientific spirit has proven to be successful in the
world of scientific software development as well.  

The open source development model also has some drawbacks which came
to light throughout the lifetime of the project.  One drawback is that
component development is only focused on what contributors find useful
for their own work.  Because developers tend to be technically
advanced, the code documentation and tutorials have been geared
towards these types of advanced users.  Further, when a
strong developer has left the project, it has not always been
immediately possible to find a contributor willing to carry on the
portion of the project for which the original developer was
responsible.  As a result, some parts of the project have been
temporarily neglected, and in some cases phased out.

We have addressed these issues by establishing guidelines for
contributions that includes a commitment to comprehensive
documentation, and high standards for released code.  When necessary,
we gracefully retire unmaintained components by providing deprecation
warnings to the community, and at all times endeavor to ensure that
there is a clear migration paths from deprecated modules to new
modules that provide equivalent functionality.


In the future, Bioperl will continue to evolve, addressing more domains
of bioinformatics.  We plan to create objects to manage sequence
assembly information, haplotype maps, gene expression, and protein
interaction data.  Additionally, projects focusing on multi-species
comparisons will build Perl modules to manage alignment and syntenic
information.  We will create software layers to interact with OBDA
databases, develop a generic analysis pipeline system to provide
automated analysis components, and expand the supported file formats
the toolkit can read and write.

\section{Acknowledgments}

The Bioperl Core is comprised of, given in alphabetical order: Ewan
Birney, Hilmar Lapp, Heikki Lehv\"{a}slaiho, Jason Stajich, and
Lincoln Stein.  The authors would like to acknowledge contributions
from the following people, given in alphabetical order: Brad Chapman,
Michele Clamp, Tony Cox, James Cuff, Andrew Dalke, Allen Day, Arne
Elofsson, Mark Fiers, Ed Green, Roger Hall, Peter van Heusden, Joseph
Insana, Nicolas Joly, Aaron J Mackey, Emmanuel Mongin, Jong Park,
Lorenz Pollak, Richard Resnick, Todd Richmond, Gert Thijs, Charles
Tilford, Andrew Walsh, Kai Wang, and Alex Zelensky.

Additional ideas and help came from other OBF project team members
including Jeff Chang, Thomas Down, Keith James, and all of the Bioperl
mailing list members.  Some parts of the object model, especially
locations, were adopted from the excellent work of the Biojava project
and its leaders Thomas Down and Matthew Pocock.

%This was the 1st submission text we go back to the original
%as Steven/Steve/Georg/Ewan agreed
%We would like to especially acknowledge the individuals who helped
%establish project in the early years, Ewan Birney, Steven Brenner,
%Steve Chervitz, Chris Dagdigian, and Georg Fuellen.  Thanks to Brian
%Osborne and Peter Schattner for their documentation and tutorial work,
%and Chris Dagdigian for his tremendous support as computer systems
%administrator for the OBF.

% alternative that we won't use at this point
% 
We would like to especially acknowledge the former project
coordinators, in chronological order: Steven Brenner, Chris Dagdigian,
Georg Fuellen, Steve Chervitz, and Ewan Birney as well as initial
contributors Jong Park and Richard Resnick who provided help
establishing the project.  Thanks to Brian Osborne and Peter Schattner
for their documentation and tutorial work, and Chris Dagdigian for his
tremendous support as computer systems administrator for the OBF.

The Bioperl project and its sister projects (commonly referred to as
the Bio\{*\} projects) are supported under the umbrella of the Open
Bioinformatics Foundation (\url{http://www.open-bio.org}).  OBF has
received hardware donations from Compaq and Sun Microsystems, and we
graciously accept donated bandwidth and computer server space from
Wyeth Research.

J.E.S is supported by an NIH Genetics training grant.  Thanks to
F.Dietrich, M.DeLong, M.Hahn, and two anonymous reviewers for their
comments on this manuscript.

\bibliography{bioperl}
\bibliographystyle{genomeres} 

\newpage

\begin{center}{\large \textbf{Captions}}\end{center}
% for genome research system

\begin{center}{\large \textbf{Website References}}\end{center}
\par \noindent
\url{http://industry.ebi.ac.uk/openBQS/}, BQS - Bibliographic Query Service.\\
\url{http://www.bsml.org}, BSML - Bioinformatic Sequence Markup Language. \\
\url{http://www.biocorba.org}, BioCORBA Project. \\
\url{http://www.biojava.org}, Biojava Project. \\
\url{http://www.bioperl.org}, Bioperl Project. \\
\url{http://www.biopython.org}, Biopython Project. \\
\url{http://doc.bioperl.org}, Bioperl code documentation page \\
\url{http://www.fruitfly.org}, Berkeley Drosophila Genome Project.\\
\url{http://www.bioxml.org/dtds/index.html},  GAME - Genome
Annotation Markup Elements. \\ 
\url{http://www.cvshome.org}, CVS Home Page. \\
\url{http://www.ensembl.org}, EnsEMBL Project Home page. \\
\url{http://www.ebi.ac.uk}, EMBL Outstation - European Bioinformatics
Institute. \\ 
\url{http://www.pasteur.fr}, L'Institut Pasteur (Pasteur Institute). \\
\url{ftp://ftp.ncbi.nih.gov/toolbox/ncbi_tools/}, NCBI Toolkit. \\
\url{http://industry.ebi.ac.uk/novella/}, EBI Novella project \\
Institute. \\ 
\url{http://obda.open-bio.org}, Open Bioinformatics Database Access. \\
\url{http://www.open-bio.org}, Open Bioinformatics Foundation. \\
\url{http://lsr.ebi.ac.uk}, Object Management Group's Life Science Research group. \\
\url{http://opensource.org/docs/definition.html}, Open Source
Initiative - Open Source definition. \\
\url{http://pdoc.sourceforge.net}, Pdoc Home Page. \\
\url{http://forkhead.cgr.ki.se/TFBS/}, TFBS Project. \\

\newpage
% for right hand top labels

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}

\rhead{Stajich\_Table\ref{tab:modules}}

\begin{table}[h]
\begin{tabular}{|l|l|}
\hline
\textbf{Modules} & \textbf{Description} \\
\hline
Bio::Seq &  Sequences and their properties \\
Bio::SeqIO & Sequence data input/output \\
Bio::Index & Flat-file sequence database indexing and retrieval \\ 
Bio::DB & Remote database access for sequences and references via HTTP \\
Bio::DB::GFF & SQL GFF database for DAS and GBrowse backends \\
Bio::SeqFeature & Feature representation and annotation \\
Bio::Annotation & Generic annotation \\
Bio::AlignIO, Bio::SimpleAlign   & Multiple sequence alignments and their Input/Output \\
Bio::LiveSeq, Bio::Variation & Sequence variations and mutations \\
Bio::SearchIO, Bio::Search  & Sequence database searches and their Input/Output \\
Bio::Tools &  Miscellaneous analysis tools \\
Bio::Tools::Run &  Wrapper for executing local and remote analyses \\
Bio::Tree, Bio::TreeIO & Phylogenetic trees and their Input/Output  \\
Bio::Structure & Protein structure data \\
Bio::Map, Bio::MapIO & Biological maps and their Input/Output \\
Bio::Biblio, Bio::DB::Biblio & Bibliographic References and Database
retrieval \\ 
Bio::Graphics & Graphical displays of sequences \\
\hline
\end{tabular}
\caption{Major Bioperl module groups}
\label{tab:modules}
\end{table}

\newpage

\rhead{Stajich\_Figure1\_caption}

Figure 1.  Rendering a sequence graphically with Bio::Graphics.  This
image represents a 20 Kb segment of the \textit{C. elegans} genome
containing annotated genes, a cross-species alignment
(\textit{C. elegans} to \textit{C. briggsae}), EST alignments, SNPs,
PCR primer pairs, and a GC content histogram.  The module's flexible
glyph-based architecture allows the application programmer to
precisely adjust how to display biological objects.  Glyphs allow the
programmer to define different symbols for different data types or
data sources and each are drawn as a separate track in the image.  The
module is also suitable for illustrating the extent of protein
domains, physical (clone) maps, and horizontal maps.

\newpage

\rhead{Stajich\_Figure2\_caption}

Figure 2. This figure shows a portion of the Bioperl object model
including the interfaces (shown in italicized type) for sequences
(PrimarySeqI, SeqI, RichSeqI) and their implementations PrimarySeq
(general sequence), Seq (sequence with features), RichSeq (sequence
with features and rich annotation), LargePrimarySeq (for sequences too
large to be held in a program's memory), and LargeSeq (large sequences
with features).  Also included in the diagram is the sequence feature
interface (SeqFeatureI) and its implementations Similarity (manage
similarity information), FeaturePair (paired feature information), and
SimilarityPair (paired similarity information such as a pairwise
alignment information).  Additionally the diagram shows the location
objects which manage Simple (start, end, and strand information),
Split (multiple start and end spots on a sequence such as a set of
exons), and so-called Fuzzy locations (where start, end or span is not
exact) for sequence features.

\newpage

\rhead{Stajich\_Figure3\_caption}

Figure 3. Retrieving a sequence from a remote database with
Bio::DB::EMBL.  This code retrieves an mRNA sequence in EMBL format
from the EBI EMBL databank with the accession number U14680 and writes
the sequence out in GenBank format to the terminal.  One could replace
Bio::DB::EMBL with Bio::DB::GenBank and instead retrieve the sequence
from NCBI just as easily since the software can read and write both
EMBL and GenBank formats and is able to connect to both services
through the World Wide Web.  The retrieved sequence can then be passed
to Bio::Graphics for graphical rendering, to the Bio::SeqIO interface
for writing to a file, or to the ODBA interfaces for storage in a
relational database.

\newpage

\rhead{Stajich\_Figure4\_caption}

Figure 4. Report parsing with Bio::SearchIO.  This code parses a BLAST
report from a file called 'report.bls' and saves, in an array called
@HitsToSave, only the hits which have High-scoring Segment Pairs (HSPs)
meeting an e-value and length threshold.  In this case, any hit with
e-value greater than 0.001 or length less than 120 residues will be
excluded.  Once the array is built, the names of each of the hits
which had a HSP that met the criteria are printed out.  To parse a
FASTA \cite{fasta} report file one simply changes the format
specification from 'blast' to 'fasta'.

\newpage

\singlespacing

% shrinking it may look better if they work with the original PDF 
% so I am submitting that as a separate page
%\newpage
%
%\rhead{Stajich\_Figure2}
%
%\begin{figure}[ht]
%\centerline{\epsfig{file=objectdiagram.pdf, width=8in}}
%\end{figure}

\newpage

\rhead{Stajich\_Figure3}
\begin{verbatim}
use Bio::DB::EMBL;
use Bio::SeqIO;

my $db = new Bio::DB::EMBL();
my $seq = $db->get_Seq_by_acc("U14680");
my $seqout = new Bio::SeqIO( -format => "genbank");
if (defined $seq) { 
   $seqout->write_seq($seq);
}
\end{verbatim}
% $

\newpage

\rhead{Stajich\_Figure4}
\begin{verbatim}
use Bio::SearchIO;
# Let's parse a BLAST report 
my $search = new Bio::SearchIO( -format => 'blast',
                                -file   => 'report.bls');
my @HitsToSave = ();
my $cutoff_Evalue = 0.001; 
my $cutoff_Len    = 120;   
# iterate over each query sequence
while(my $result   = $search->next_result) {
  # iterate over each hit on the query sequence
  while(my $hit = $result->next_hit) {
    # iterate over each HSP in a hit
    while( my $hsp  = $hit->next_hsp ) {
      if( $hsp->evalue < $cutoff_Evalue && 
        $hsp->length('total') >= $cutoff_Len ) { 
        push @HitsToSave, $hit;
        last; # Only want to process each Hit once
      } 
    }
  }
}

print "Hits:\n";
foreach my $hit ( @HitsToSave ) {
  print $hit->name, "\n";	
}

\end{verbatim}


\end{document}
