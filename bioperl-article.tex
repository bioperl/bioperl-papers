\documentclass[12pt]{article}
% $Id: bioperl-article.tex,v 1.11 2002-03-24 20:49:13 jason Exp $
% $Log: not supported by cvs2svn $
% Revision 1.10  2002/03/21 21:50:04  jason
% reworked abstract for GR and moved examples around.  Reworked abstract for GR and moved examples around.  Added statistics about tests and number of modulesTable for Modules rather than list.
%
% Revision 1.9  2002/03/19 10:58:47  heikki
% fixing examples, lot's of typos in the docs, minor changes
%
% Revision 1.8  2002/03/13 21:21:08  jason
% 3rd draft - with Lincoln's changes
%
% Revision 1.7  2002/03/04 22:18:09  jason
% Some reworking of text, placeholders for expansion on the major 
% theme of open-source developmentmore references and testing out 
% the lstlisting for code section, lines
% are not wrapping nicely though in 2-column mode with the code,
% Author list still incomplete and need to move acknowledgements
% around some more
%

\usepackage { listings,url,cite,layouts,graphics,keyval,fullpage,
 doublespace }

\begin{document}

\title{The Bioperl Toolkit}
% Not sure how to do this - some people should be in the title?
\author{Jason E Stajich$^1$ \and
Hilmar Lapp$^2$ \and
Heikki Lehv\"{a}slaiho$^3$ \and 
Lincoln D Stein$^4$ \and Ewan Birney$^3$ \and
Bioperl Project Team \thanks{Bioperl Mailing List bioperl-l@bioperl.org} \\
$^1$ \small{\textit{University Program in Genetics, Duke University,  Durham, NC USA}} \\
$^2$ \small{\textit{GNF, San Diego, CA USA}} \\
$^3$ \small{\textit{European Bioinformatics Institute, Welcome Trust
Genome Campus, Hinxton, Cambridge UK}} \\
$^4$ \small{\textit{Cold Spring Harbor Laboratories, Cold Spring Harbor, NY USA }}\\
}
\maketitle
\begin{abstract}

[BEING REWORKED AGAIN]
The Bioperl project, an international open source
collaboration of biologists, bioinformaticists, and computer
scientists that has evolved over the last 7 years into the most
comprehensive library of object-oriented Perl modules for manipulating
and managing life science information.  Bioperl provides an
easy-to-use, mature, stable, and consistent programming interface for
bioinformatics application programmers.  Bioperl has been successfully
and repeatedly used to achieve otherwise complex tasks with only a few
lines of code.  The Bioperl object model has been proven to be
flexible enough to support enterprise-level applications such as EnsEMBL,
while at the same time keeping an easy learning curve for novice Perl
programmers.  Bioperl is also capable of interoperating with other
programming languages like Python and Java through the evolving
BioCORBA bridge and the accessing common data storage through the
BioSQL and Open Bioinformatics Database Access (OBDA) projects.  The
successful development of Bioperl depended in a large part on the open
source nature of the project.  We outline how this approach is a
valuable mechanism for collaborative projects.

[ Bioperl is available as open source software free of charge licensed
under the Perl artistic license at \url{http://www.bioperl.org/}. ]

\textbf{Contact:} Bioperl project list \url{bioperl-l@bioperl.org}.

\end{abstract}

\section{Introduction}

  Biological sequence data in public databanks has grown exponentially
since their inception making it necessary to use automated methods to
of sifting through the data.  Computer software allows one to
efficiently search data for specific criteria, but often the searches
need to be coupled with additional analyses in an automated fashion.
[NEED BETTER TRANSITION HERE TO THE NEXT 2 paragraphs]
By learning to write computer programs, biologists can control
the creation of the software to complete the tasks and automate analyses to ask questions in a genomic context rather than on
an individual gene basis.  

One programming language, Perl, is by far
the most widely used programming language in bioinformatics, and is
commonly thought of as the language most easily grasped by newcomers
to the field.  Perl has been extremely successful for connecting
programs together into sequence analysis pipelines, converting file
formats, and extracting information from the output of analysis
programs and other text files.  However, a significant part of the
code of Perl bioinformatics applications, and consequently of the
development time spent, consists of recurrent tasks, leading to a high
extent of code duplication in the bioinformatics community.  Novice
Perl programmers in the field are often unfamiliar with software
engineering concepts directed at alleviating the problem, such as
modular design building generic modules from re-usable components.

At the time of Bioperl's inception in 1995 \cite{chervitz-bits} there
were few programming toolkits for manipulating biological data and
results from sequence analysis programs.  Although Perl had already
gained widespread popularity in the bioinformatics community for its
efficient support of text processing and pattern matching tasks, there were in fact no biological toolkits available in
this language.  Non-programmers have found Perl to be easy to learn,
making it a great way to put the power of the computer directly into
the hands of the biologist and removing their dependence on a
computer programmer to provide the solution.

While most compute-intensive analysis algorithms are implemented as
stand-alone programs in compiled languages like C for efficiency
reasons, scripting languages are ideal for interpreting and combining
results from these analysis programs.  Much of the work in
bioinformatics is applying logic to filter and combine outputs in
order to present summaries to users.  
 
[POSSIBLY DELETE]
Much of the initial efforts in bioinformatics involved writing scripts
to run and parse output from programs in C-language packages such as
GCG \cite{Devereux1984}.  Because GCG supported a common file format
between many of its components, these scripts had full generality
across the GCG suite.  However, as more sequence analysis packages
became available, this homogenity broke down so that it became
difficult to use the same script with multiple tools.  Additionally
the programmer bore the responsibility of maintaining and adapting
scripts whenever program parameters or formats changed.  
The output from different analysis programs for the same
purpose, like different alignment programs, represented similar
information in different formats.  Hence it was impossible to create
generic scripts to treat external programs as pluggable components.
[/POSSIBLY DELETE]

The Bioperl project grew out of the following observations.  
\begin{itemized}

\item First, Even though file formats of different analysis programs
are different, the information they represent is the same.  For
example, a pair-wise alignment is always between two sequences and has
common properties such as length, score, fraction of identities, start
and end of the aligned sequences, and so forth.

\item Second, the number of data structures needed to represent
information flow is limited, and common to most applications, such as
sequences, annotation, features, and alignments.  This permits a small
set of modules to be reused for variety of purposes and avoids
creating a confusing hierarchy of components.

\item Third, a set of operations is performed on these data structures
that are useful for a variety of tasks.  This include reading and
writing information to a file, querying a sequence for its features,
and translating a gene coding sequence into protein.  

This scenario naturally lends itself to the principle of
object-oriented programming, which Perl emulates with modules.  A
module corresponds to the notion of a 'class' in object-oriented
languages.  Hence, the mission of Bioperl is to provide an easy-to-use
object-oriented Perl library that encapsulates data structures and
operations commonly used in the life sciences as clean, generic, and
re-usable modules.  The goal of Bioperl is to help programmers focus
on the problems of their specific application because Bioperl provides
ready-to-use solutions for those common data types and operations.  An
additional goal is to design a data and object model that is easy for
Perl novices to learn while also being flexible enough to use in
enterprise applications.

Over time, Bioperl has evolved into the most comprehensive toolkit for
bioinformatics available in Perl.  The programming interface is stable
and mature in the recent release of version 1.0.

\section{Systems and Methods}

Bioperl is written purely in Perl and requires at least version 5.005
of the Perl interpreter being installed.  The toolkit has been checked
for cross-platform compatibility on most UNIX and UNIX-like operating
systems in addition to Macintosh OS X and Microsoft Windows operating
systems.  Since the toolkit is run through the Perl interpreter
specific issues are often due to compatibility between different
versions of Perl.  Descriptions of specific bugs and their solutions
are available from the Bioperl website.

In addition to pure Perl solutions to bioinformatics problems, Bioperl
can take advantage of external data analysis packages.  Currently the
toolkit supports the EMBOSS \cite{emboss} suite, NCBI BLAST
\cite{blast}, and the multiple sequence alignment programs Clustal-W
\cite{clustalw} and T-Coffee \cite{tcoffee}.  In some cases, when an
external package is not available Bioperl will fall back to using a
slower method, either emulating the package in pure Perl or by
invoking a network based analysis service such as the NCBI BLAST
analysis queue.  Additional work is in progress to incorporate remote
analysis services at the EBI and Pasteur Institutes in order to add
the capability of many software applications without requiring a
locally installed copy.

\section{Object and Data Model}

At present the objects and operations in Bioperl center around
biological sequence analysis and annotation.  Genomic sequencing
projects have used Bioperl to build analysis pipelines and database
access interfaces.  Additional objects to handle multiple sequence
alignments, phylogenetic trees, protein structure data, bibliographic
queries and data, and relational database interfaces.

\subsection{Object hierarchy}

Bioperl has 16 major modules and over 300 subclasses and comprises
over 160,000 lines of code and embedded documentation.  These include
modules which handle sequence, analysis, phylogenetic trees, protein
structure, maps, and bibliographic references.  The perl modules are
organized by logical names so that, for example, the Bio::Search
hierarchy contains modules related to database searches and
Bio::Graphics contains modules that are related to drawing.


\begin{table}[p]
\begin{tabular}{|l|l|}
\hline
\textbf{Modules} & \textbf{Description} \\
\hline
Bio::Seq &  Sequences and their properties \\
Bio::SeqIO & Sequence data input/output \\
Bio::Index & Local sequence database indexing and retrieval \\ 
Bio::DB & Remote database access for sequences and references via HTTP \\
Bio::DB::GFF & Local GFF database for DAS and GMOD \\
Bio::SeqFeature & Feature representation and annotation \\
Bio::Annotation & Generic annotation \\
Bio::AlignIO, Bio::SimpleAlign & Multiple alignment representation \\
Bio::LiveSeq, Bio::Variation & Sequence variations and mutations \\
Bio::SearchIO, Bio::Search  & Sequence database searches and their Input/Output \\
Bio::Tools &  Miscellaneous analysis tools \\
Bio::Tools::Run &  Wrapper for executing local and remote analyses \\
Bio::Tree, Bio::TreeIO & Phylogenetic trees and their Input/Output  \\
Bio::Structure & Protein structure data \\
Bio::Map, Bio::MapIO & Biological maps and their Input/Output \\
Bio::Biblio, Bio::DB::Biblio & Biblopraphic References and Database
retrieval \\ 
Bio::Graphics & Graphical displays of sequences \\
\hline
\end{tabular}
\caption{Major Bioperl module groups}
\label{modules}
\end{table}

\subsection{Design principles}

When designing the library's object hierarchy, our objective was to
provide a programming interface that is very easy to use but that at
the same time could be easily extended in its capabilities and behaviour
through code reuse.  Using the object-oriented paradigm to design
our modules we followed certain design principles.  

\begin{itemize}

\item Separating the interface from the implementation.  The key
information about an object class is the list of arguments to pass to
the object's methods.  By putting this information into its own
module, called an interface, the actual implementation can be provided
by multiple independent libraries without risk of clashes.  This is
preferable to requiring that each implementation inherit from a common
base class, which has scaleability problems as object classes become
increasingly complex.

\item Generalize common routines into a module.  When many modules
follow the same route to accessing data it is useful to group those
routines together.  A good example of this is data Input/Output (IO).
A toplevel IO object called Bio::Root::IO was created to manage basic
access to files and data streams.  All modules that need data access
inherit from the IO module and use the same read and write functions.
This approach lends itself to consistency across the entire package;
all implementations using the IO module will do so consistently making
it easy for developers to evaluate each other's code.  It is also ease
share any enhancements to the common methods because any changes made
in the parent module will be inherited by the child modules.

\end{itemize}

In Bioperl we followed these two design patterns \cite{gangoffour}
throughout the library wherever possible.  Most classes come as an
interface, with a capital 'I' appended to the object name (e.g.,
Bio::SeqI and Bio::Seq), together with a ready-to-use fully functional
implementation.

In order for us to produce fairly uniform software code we established
some coding guidelines that are extensions of good object-oriented
programming.  All modules were required to meet minimal standards
before releasing.  These standards included a complete set of
regression tests, well formed embedded documentation for each method,
and a concise example code in the SYNOPSIS section of each module's
documention.  The Perl embedded documentation format called POD, or
Plain Old Documentation, is used to provide annotation within the
source code.  This documentation can be converted to text, TeX, or
HTML.  We have used the Pdoc\cite{pdoc} tool to generate colored and
organized documention in HTML for easy online browsing.

Part of the development process is to insure that all parts of the
code are tested.  This is accomplished by insuring that each module
has a test in the Bioperl test system.  This approach is effective in
locating newly introduced bugs and is a tenent of the Extreme
Programming\cite{xprogramming} methodology which we use in some
aspects of our development process.  The Extreme Programming approach
to tests is to build the test first and then build one's object to
insure that all aspects of implementation were correctly completed.
We attempt to follow many of the Extreme Programming approaches for
developing software which emphasizes quick production of working code. 
The Bioperl 1.0 release has over 3000 tests which help us insure the
quality of the release and check that new changes to the code base do
not break existing functionality.

To support multiple developers in different time zones and
institutions, a centralized repository for the source code for the
project was setup in Boston, MA.  The Open Bioinformatics
Foundation (OBF) was founded, in part, to provide server space for
source code repositories and websites to various open source
bioinformatics toolkits.  Using a software development tool called CVS
(Concurrent Version Control system) \cite{cvs,cvsbook}, multiple
developers can work on the code at the same time and commit their
changes to the source code changes into a central repository.  The
ability to share code easily and quickly is one of the primary
building blocks in establishing a successful open source project.

\section{Results}

Bioperl has 10 active developers led by a core of 5 primary developers
who insure that standards are met, prepare code releases, and set the
vision for the project.  The mailing lists for the project include
1300 subscribers and about 10,000 unique visitors to our website each
month.  The project has been used in variety of endeavors including
genome sequencing, annotation, sequence variation elucidation, disease
gene discovery, and comparative genomics.

\subsubsection{Applications built with Bioperl}

By far the most advanced use of the Bioperl toolkit has come through
the EnsEMBL\cite{ensembl-nar} project.  The basic sequence handling,
file format parsing, and sequence features for annotation model have
been used as building blocks for automatically annotating the
\textit{Homo sapiens}, \textit{Drosophila melanogastor}, \textit{Fugu
ripes}, and \textit{Mus musculus} genomes.

Additionally the Genquire\cite{genquire} annotation package makes use
of the Bioperl object model and stores sequence and annotation data in
a persistent database model.  The sequence rendering capabilities are
partitioned into a specific Bioperl package called bioperl-gui.  The
database model used by Genquire has been updated to utilize the new
BioSQL(\url{http://obda.open-bio.org}} sequence database design, which
will allow the other OBF toolkits to access data written by the
Genquire system.

The Generic Model Organism Browser (GMOD) \cite{gmod}, Distributed
Annotation System Perl (DAS) server \cite{das,biodbgff}, and TFBS
\cite{tfbs} all use the Bioperl object model to describe sequences and
Bioperl tools to complete analyses.  The GMOD system is a web
interface to databases of features for a genome project.  The DAS
system provides researchers a means to locally annotate sequences and
publish the annotations to the community via the DAS XML protocol.
TFBS provides a perl implementation of objects for DNA sequence pattern
representation by matrix profiles, with associated methods for searching
the sequences for the occurence of patterns, pattern storage, and
generation of new patterns. The implementation uses bioperl sequence,
alignment, sequence feature and feature pair objects.

\subsection{Interoperability}

% Need help cutting down

Sometimes the best solution for a bioinformatics problem is a hybrid
of multiple tools.  These tools, written in different programming
languages such as C, Java, and Python, can be used within a Perl
script simply by invoking them (a process often called "shelling
out").  In some situations these tools require that data be available
in a certain format or within a certain database.  Bioperl provides
software layers which can, for example, populate a database with
sequence information which can be accessed and used to generate an
interactive graphical interface provided by the BioJava toolkit.
In other cases, Bioperl is used to create files in a format recognized
by other programs so that they can perform their analyses. 

The Extensible Markup Language (XML) provides a means for creating
data in a language and platform independent manner.  Previous work has
outlined scenarios where XML has been useful in a biological context
\cite{xml_bioinformatics}.  Bioperl supports several XML standards for
biological data including BSML and (read only) GAME (read/write)
sequence markup formats.  Bioperl can parse NCBI BLAST XML format in
addition to the standard blast text format.  It also supports Medline
XML (read only) provided by the European Bioinformatics Institute's
Bibliographic Query Service (BQS) and Entrez Pubmed XML format.

The Common Object Request Broker Architecture (CORBA)\cite{corba}
allows a programmer to share components developed in different
languages.  This is achieved by first agreeing upon the names of
functions and data the components will contain.  Developers write the
software for the components in their favorite language and run a
program called a server where the components can be accessed from.  A
simple example of this is a component to retrieve sequences from a
database.  It is written in the Perl and is loaded into a server
program.  A programmer will then write software in Java which connects
to the server program and requests a specific sequence by its
accession number.  The Perl component will do its job and find the
sequence and return it to the Java program.  Using these types of
building blocks larger and more complex bioinformatics solutions can
be built which can maximize the strengths of various programming
languages and environments.  An example of a proposed standard for
CORBA components for biological processes is the BioCORBA
(\url{http://www.biocorba.org}) project.  It is a collaborative
project which has involved members of the Bioperl, BioJava
(\url{http://www.biojava.org}), and Biopython
(\url{http://www.biopython.org}) projects as well as the Object
Management Group's Life Science Research group
(\url{http://lsr.ebi.ac.uk}).

This interoperability has also been applied to the EnsEMBL project.
The EnsEMBL (v. 4) software layer is a collection of perl modules
built on top of the Bioperl library.  Using an EnsEMBL-CORBA interface
derived from BioCORBA, a perl EnsEMBL CORBA server has been written
which is accessible to C, Java, and Python clients, and therefore
making the EnsEMBL data and algorithms programatically available to
these languages.

\subsubsection{Users}

A primary motivation behind writing this toolkit was the authors'
desire to not duplicate effort.  In our minds, once a solution for
parsing and interpreting sequence from Genbank format files is
written, no one else should have to worry about writing their own.  In
this spirit we chose to make our code free.

However, to be adopted by the community our software has be user
friendly.  To that end we've both provided extensive documentation of
all the methods in each module, a graphical diagram of the objects in
the toolkit, and a number of tutorials with examples of common
problems.  Additionally we have written a module named Bio::Perl which
provides a simple function-oriented interface for those who prefer
traditional procedural programming to the object-oriented metaphor.

\subsection{Example usage}

The following examples provide typical usage for some of the Bioperl
objects in simple scripts.  The first example, shown in Figure
\ref{example1}, will retrieve an mRNA sequences from the EBI EMBL
databank with the accession number U14680 and write the sequence out
in GenBank format to the screen.  One could replace Bio::DB::EMBL with
Bio::DB::GenBank and instead retrieve the sequence from NCBI.

In the second example, shown in Figure \ref{example2}, a BLAST report
is parsed and only certain hits meeting an e-value and length
threshold are saved.  In this case any hit with evalue greater than
0.001 or length less than 120 residues will be excluded.  Once the
list of hits is built one can print out the name of each of the Hits
which had High Scoring Pairs (HSPs) that met the criteria. 

\lstset{
	language=Perl,
	basicstyle=\small,
%	labelstyle=\tiny,
%	labelstep=1,
	stringstyle={} }

\begin{figure}[p]
\begin{scriptsize}
\begin{lstlisting}{}
use Bio::DB::EMBL;
use Bio::SeqIO;

my $db = new Bio::DB::EMBL();
my $seq = $db->get_Seq_by_acc("U14680");
my $seqout = new Bio::SeqIO(-format => "genbank");
if (defined $seq) { # in case DB doesn't return anything
    $seqout->write_seq($seq);
}
\end{lstlisting}
\end{scriptsize}
\caption{Sequence retrieval from the Remote GenBank Database at EMBL}
\label{example1}
\end{figure}


\begin{figure}[p]
\begin{scriptsize}
\begin{lstlisting}{}
use Bio::SearchIO;
# Let's parse a BLAST report 
my $search = new Bio::SearchIO(-format => 'blast',
          		       -file   => 'report.bls');
my @HitsToSave;
my $cutoff_Evalue = 0.001; # max e-value is 0.001
my $cutoff_Len   = 120;    # min length of 120 residues
while(my $result = $search->next_result) {
 HIT:while(my $hit = $result->next_hit) {
   while( my $hsp = $hit->next_hsp ) {
    if( $hsp->evalue < $cutoff_Evalue && 
	$hsp->length('total') >= $cutofflen ) { 
	push @HitsToSave, $hit;
	next HIT;
      } 
   }
  }
}

# process hits that meet criteria
print "Hits:\n";
foreach my $hit ( @HitsToSave ) {
  print $hit->name, "\n";	
}

\end{lstlisting}
\end{scriptsize}
\caption{BLAST parsing}
\label{example2}
\end{figure}

% balance $ for my emacs

\subsection{Future Plans}

Bioperl will continue to evolve in order to address more issues in
bioinformatics.  We have plans to create objects to manage sequence
assembly information, haplotype maps, gene expression, and protein
interaction data.  Additionally, projects focusing on multi-species
comparisions are building Perl modules to manage the alignment and
syntenic information.  We are creating software layers to interact
with BioSQL project\cite{biosql} databases, developing an analysis
pipeline system to provide automated annotation, and expanding the
supported file formats the toolkit can read and write.

\section{Conclusions}

Much of the success of the Bioperl toolkit development effort can be
attributed to the Open Source nature of the development effort which
has allowed a diverse group of individuals to participate in
collaborative project.  By encouraging users of the toolkit to also
assist in the development of it, contributions are made back to the
source code base which can benefit all users.  This collaborative
effort and the strong need to get working software written in
an extensible manner has made Bioperl an excellent platform for Perl
bioinformatics software development.  This open sharing of ideas that
embodies the scientific spirit is successful in the world of software
development for scientific purposes as well and has permitted the
toolkit to grow in directions pertinent to its users.

\section{Acknowledgements}

The Bioperl Core is Jason Stajich, Hilmar Lapp, Heikki Lehväslaiho,
Lincoln Stein, and Ewan Birney.  The project has seen signifigant
contributions from the following people David Block, Kris Boulez,
Steven Brenner, Brad Chapman, Steve Chervitz, Michele Clamp, Tony Cox,
James Cuff, Chris Dagdigian, Andrew Dalke, Allen Day, Arne Elofsson,
Mark Fiers, Georg Fuellen, James R Gilbert, Ed Green, Roger Hall,
Peter van Heusden, Joseph Insana, Nicolas Joly, Ian Korf, Aaron J
Mackey, Brad Marshall, Chad Matsalla, Chris Mungall, Emmanuel Mongin,
Brian Osborne, Lorenz Pollak, Matthew Pockock, Todd Richmond, Martin
Senger, Peter Schattner, Elia Stupka, Gert Thijs, Charles Tilford,
Andrew Walsh, Kai Wang, Mark Wilkinson, Alex Zelensky.

Additional ideas and help came from other Open Bioinformatics project
team members including Jeff Chang, Thomas Down, Keith
James, and all of the bioperl mailing list members.

We would like to especially acknowledge Steve Chervitz for his
previous role as bioperl project leader, Brian Osborne and Peter
Schattner for their excellent documentation and tutorial work, and
Chris Dagdigian for his tremendous support as system administrator for
the project computers. 

The Bioperl project and its sister projects (commonly referred to as
the Bio\{*\} projects) are supported under the umbrella of the Open
Bioinformatics Foundation (OBF) \url{http://www.open-bio.org}.
OBF is supported by hardware donations from Compaq and Sun
Microsystems, and we graciously accept donated bandwith and computer
server space from Wyeth.

J.E.S is supported by NIH Genetics training grant \#T32GM07754-22.
Thanks to F.Dietrich, M.DeLong, M.Hahn for comments and suggestion.

\bibliography{bioperl}
\bibliographystyle{plain} 

\end{document}
