\documentclass[twocolumn]{article}
% $Id: bioperl-article.tex,v 1.7 2002-03-04 22:18:09 jason Exp $
% $Log: not supported by cvs2svn $

% conventions -
%
% Interfaces are in italics
% Module names in Bold
% method names in bold italics
%
% when describing the bioperl objects, list all
% the applicable interfaces and objects at the beginning
% of the subsection like
% Objects: Object1 Object2
% Interfaces: Interface1 Interface2

% Things that have not been discussed

% EWAN - Let's Add Pfam, Sanger, and EnsEMBL examples 
% in here if possible

\usepackage {
 listings,bioinformatics,url,layouts,graphics,keyval
% fullpage,fancyheadings,lscape,rotating,
% float,longtable,epsfig,psfig,layouts,
}

\begin{document}

\title{The Bioperl Toolkit}
% Not sure how to do this - some people should be in the title?
\author{Jason Stajich \thanks{University Program in Genetics, 	
	Duke University, Durham, NC 27710. jason@bioperl.org } \and 
Hilmar Lapp \thanks{GNF San Diego, CA hilmarl@yahoo.com } \and 
Heikki Lehvaslaiho \thanks{European Bioinformatics Institute Hinxton,
	UK heikki@ebi.ac.uk } \and 
Lincoln Stein \thanks{Cold Spring Harbor Laboratories,Bungtown Rd,
	Cold Spring Harbor, NY. lstein@cshl.org} \and
Ewan Birney \thanks{European Bioinformatics Institute Hinxton, UK
	birney@ebi.ac.uk } \and 
Bioperl Project Team \thanks{bioperl-l@bioperl.org}
}
\maketitle

\begin{abstract}

\textbf{Motivation:} Perl is by far the most widely used programming
language in various domains of bioinformatics, which is commonly
attributed to the language being grasped quickly even by newcomers to
the field, and to Perl's many text-processing features.  Perl has been
extremely successful for connecting programs together into pipelines, 
converting between different file formats, and extracting the
desired information from the output of analysis programs.  However, a
significant part of the code of Perl bioinformatics applications, and
consequently of the development time spent, consists of re-occurring
tasks, leading to a high extent of code duplication in the
Bioinformatics community.  Novice Perl programmers in the field are often
unfamiliar with software engineering concepts directed at alleviating
the problem, such as abstracting re-usable components into generic
modules and applying .

\textbf{Results:} Here we report about the Bioperl project, which is
an international open-source collaboration of biologists,
bioinformaticists, and computer scientists that has evolved over the
last 7 years into the most comprehensive library of object-oriented
Perl modules for manipulating and managing life science information.
Bioperl provides an easy-to-use, mature, stable, and consistent
programming interface to bioinformatics application programmers.
Bioperl has been successfully used to achieve otherwise complex tasks
with only few lines of code.  We report about the object and data
model we conceived to represent various entities one frequently has to
deal with in the bioinformatics domain.  The Bioperl object model has
been proven to be flexible enough to build enterprise-level
applications like EnsEMBL \cite{ensembl-nar} on top of it, while at the
same time keeping a shallow learning curve even for inexperienced Perl
programmers.  Bioperl is also capable of interoperating with other
programming languages like Python and Java through the evolving
BioCORBA bridge.

\textbf{Availability:} Bioperl is available as open-source software free
of charge licensed under the Perl artistic license at \url{http://www.bioperl.org/}.

\textbf{Contact:} Bioperl project list \url{bioperl-l@bioperl.org}.

\end{abstract}

\section{Introduction}

At the time of Bioperl's inception in 1995 \cite{Fullen1995} there
were few programming toolkits for manipulating biological data and
results from sequence analysis programs.  There were in fact none
available in Perl \cite{Wall2000}, a scripting language that quickly
gained widespread popularity in the bioinformatics community for its
efficient support of text processing tasks.  Perl's success in
bioinformatics can also be attributed to its powerful regular
expression integration coupled with the ability to chain together
execution of programs and its efficient text processing.
Non-programmers have found perl to be easy to learn and a great means
to put the power of the computer into the hands of the biologist
rather than the scientist relying on a computer programmer to provide
the solution.

While most compute-intensive analysis algorithms are implemented as
stand-alone programs in compiled languages like C for efficiency
reasons, scripting languages are ideal for interpreting and combining
results from these analysis programs.  Much of the work in
bioinformatics is applying logic to combining these outputs and
presenting the summaries to users.  
 
Much of the initial work in bioinformatics involved writing script to
run and parse output from programs in a package such as GCG
\cite{Devereux1984}. It supported a common file format between many of
the programs so one was able to write a single script to do much of
the work.  However as other tools became available which used
different file formats, or the options and formats it was difficult to
use the same script to peform a job with multiple tools, additionally
these scripts bear the difficulty that they require an intimate
knowledge of the programs' parameters, and how they have to be changed
to achieve the desired behaviour.  Scripts were inherently dependent
on the particular program being run, not only on the kind of
algorithm.  The output from different analysis programs for the same
purpose, like different alignment programs, represented similar
information but in different formats.  Hence it was impossible to
create generic scripts treating external programs as pluggable
components.

The Bioperl project grew out of the following observations.  First,
even though file formats of different analysis programs are different,
the represented information is the same.  For example, a pair-wise alignment
is always between two sequences and has common properties such as
length, score, fraction of identities, start and end on both sequences, etc. 

Second, the number of data structures needed to represent the
information flow is limited, and common to most applications, like
sequences, annotation, features, and alignments.  The language Perl
itself has no native way of defining abstract data types, unlike
e.g. C.

Third, a large number of operations performed are common between
applications, like parsing a data entity out of an input stream,
writing manipulated entities, filtering a stream of data entities to
screen for certain criteria, etc. 

This scenario naturally lends itself to the principle of object
oriented programming, which Perl emulates by modules.  A module
corresponds to the notion of a `class' in object-oriented languages.
Hence, the mission of Bioperl is to provide an easy-to-use
object-oriented Perl library that encapsulates data structures and
operations commonly used in the life sciences as clean, generic, and
re-usable modules.  The goal is that an application programmer using
Bioperl can focus on the problems specific to his or her application,
because Bioperl provides ready-to-use solutions for the those data
types and operations common to life science informatics.  In addition,
we set out to design a data and object model that is easy to learn
even for Perl neophytes, and at the same time flexible enough to build
applications up to enterprise-level software.

Over time Bioperl has evolved into the most comprehensive toolkit for
bioinformatics in Perl.  The programming interface is stable.  Our
recent release of version 1.0 underlines its maturity.  In this paper
we report about Bioperl as of its production release 1.0.

The rest of the paper is organized as follows.  First we describe the
data and object model we conceived, followed by an elaboration on
Bioperl's interoperability with bioinformatics toolkits written in
other programming languages.  Subsequently we discuss the strengths and
deficiencies of the design and the implementation of the library, also
with respect to other packages available in the field.  We conclude
with a summary of the key benefits of the toolkit for the Perl
bioinformatics programming community.

\section{Systems and Methods}

Bioperl itself is written purely in Perl and requires at least version
5.005 of the Perl interpreter being installed.  The toolkit has been
checked for cross-platform compatibility on different flavours of Unix
including MacOS X as well as on Win9x/2000/NT systems and MacOS 9.  So
far we have not encountered any incompatibilities on the Unix
platforms we tested using a modern Perl interpreter (5.005 or later).
On the MacOS and Win9x/2000/NT platforms the great majority of the
modules in the toolkit run without problems.  However, some modules
having external dependencies either as Perl modules with possibly
compiled code, or as external programs they encapsulate don't work on
these platforms due to problems in the external dependencies.  All of
the known issues are listed in platform documentation of the toolkit.

Additionally where external tools are avaiable on the local machine
Bioperl can link with installed EMBOSS \cite{emboss}, NCBI BLAST
\cite{blast}, and the multiple sequence alignment programs Clustal-W
\cite{clustalw} and T-Coffee \cite{tcoffee}.

\section{Object and Data Model}

At present the objects and operations in Bioperl center around
biological sequence analysis and annotation.  Genomic sequencing
projects have been one of the primary use cases for building analysis
pipelines and database interfaces on top of Bioperl.   Additional
objects to handle Multiple Sequence alignments, Phylogenetic Trees,
Protein Structure data, Bibliographic queries and data, and relational
Database interfaces.

\subsection{Object hierarchy}

\begin{itemize}
\item Sequences and their properties. (Bio::Seq)
\item Sequence input/output.  (Bio::SeqIO) 
\item Sequence database indexing and retrieval. (Bio::Index) 
\item Feature representation and annotation. (Bio::SeqFeature)
\item Generic annotation. (Bio::Annotation)
\item Multiple alignment representation. (Bio::AlignIO, Bio::SimpleAlign)
\item Sequence variations and mutations. (Bio::LiveSeq, Bio::Variation)
\item Parser for sequence database searches and other analysis
tools. (Bio::SearchIO, Bio::Tools)
\item Wrapper for executing local and remote analyses. (Bio::Tools::Run)
\item Phylogenetic trees and parsers. (Bio::Tree, Bio::TreeIO)
\item Protein structure data. (Bio::Structure)
\item Biological maps. (Bio::Map)
\item Bibliographic references. (Bio::Biblio)
\item Distributed Annotation Server (DAS) database \cite{das}. (Bio::DB::GFF)
\item Graphical displays of sequences. (Bio::Graphics)
\item Alphabets. (Bio::Symbol)


\end{itemize}

\subsection{Design principles}

When designing the library's object hierarchy our objective was to
provide a programming interface that is very easy to use, but that at
the same time can be easily extended in its capabilities and behaviour
through code-reuse.  While object-oriented programming naturally lends
itself to code-reuse through the principle of inheritance, to make
this work in practice for more than very simple cases it is wise to
observe certain design principles.  

\begin{itemize}

\item Separating the interface from the implementation.  The key
information about an object for a client calling its methods is the
method prototypes, making up the API of the particular class.  By
putting this API into its own module, called an interface, the actual
implementation can be provided from the library itself just as well as
from a user of the library, even in another language.  There is no risk
of interfering with certain implementation specific details as
compared to inheriting from a full implementation.

% Can someone describe this in a better way?

\item Using factories for object creation.  Certain modules need to
create other objects of the library, or more precisely, instantiate
implementations of other interfaces, in order to accomplish their
task.  For example, a sequence input driver needs to instantiate
sequence objects from the input information.  If the actual class to be
instantiated is hard-coded in the module, a client providing his or
her own implementation of the required interface cannot ask the
library to instantiate his implementation instead of that the library
provides.  Factories solve this problem; objects to be created are
obtained from a factory object, and a client can provide his own
factory object that would instantiate his own classes.

\end{itemize}

In Bioperl we followed these two design patterns \cite{gangoffour}
throughout the library wherever possible.  Most classes come as an
interface, with a capital 'I' appended to the object name (e.g.,
Bio::SeqI and Bio::Seq), together with a ready-to-use fully functional
implementation.  [A good example for the factory pattern should follow
once we have it.]


Coding standards

Documentation Standards

Testing

Extreme Programming\cite{xprogramming}


\section{Interoperability}

% Need help cutting down

While Perl is an ideal language for both novice and experienced
programmers and bioinformatics specialists one may want to take
advantage of the properties of other languages such as the graphical
capabilities of java or speed of C programs.  Numerous methods are
possible for utilizing other languages depending on where one wanted
to partition the problem and build layers into a system.  Database
layers provide data abstraction while network layers can provide
process abstraction.  These partitioning of data, objects, or
processes is a powerful means for leveraging resources in different
environments.  Typically this is easier done by communicating through
a standard.  

The Extensible Markup Language (XML) provides a means for creating
data in a language and platform independent manner.  Previous work has
outlined scenarios where XML has been useful in a biological context
\cite{xml_bioinformatics}.  Bioperl supports several XML standards for
biological data including reading BSML and reading/writing GAME
sequence markup formats.  Additionally a bioperl can parse NCBI BLAST
XML format in addition to the standard blast text format.  Finally
we support parsing in medline XML as provided by the Eurpean
Bioinformatics Institute's Bibliographic Query Service (BQS) and
Entrez Pubmed XML format. [NOTE: We don't write medline XML or read in
pub med xml YET!!]

The Common Object Request Broker Architecture (CORBA) allows a
programmer to develop client-server applications in different
languages and to build components of a program, or objects in separate
languages.  These objects live in the space of a running process on a
machine, but a programmer can execute methods on objects on different
machines, even written in a different language. CORBA was designed
with distributed objects as the primary goal, however we can take
advantage of this technology to create applications which utilize
objects written in different languages to take advantage of that
language functionality.

This cross-language interoperability is leveraged by creating a common
set of object interface definitions, written for CORBA in the
Interface Design Language (IDL).  IDL is a multi-purpose way to create
interface definitions and is useful for describing the minimal set of
method or data objects must have.  Once this contract for interfaces
has been established developers can implement the interfaces and
provide services which utilize these objects. 

For example, the bioperl project has created a robust set of sequence
parsing routines which a C programmer may want to take advantage of
rather than writing their own parser from scratch.  However C is a
more optimal language for predicting secondary structure of an RNA
sequence or calculating sequence overlaps in a contig assembly.  By
utilizing CORBA, C code can be written to simply obtain a sequence
object and query the object for the sequence bases as a string, and
apply an algorithm calculating minimal energy.  Similarly if one was
interested in integrating analysis from a new dynamic programming
toolkit written in Java into a perl based application, the necessary
components can be accessed through an interface and the CORBA layer.

The BioCORBA project is a sister project of Bioperl coordinated with
BioJava \cite{biojava} and BioPython \cite{biopython} which has
developed a standard IDL describing biological data.  Collaboration
between the BioCORBA and Object Management Group's (OMG) Life Science
Research (LSR) group has yielded a joint IDL useful for the scope of
sequence analysis which will we have implemented as the BioCORBA IDL
\cite{biocorba}.

This interoperability has also been applied to the EnsEMBL project
\cite{ensembl-nar}.  The EnsEMBL (1.3) software layer is a
collection of perl modules built on top of the Bioperl library.
Using an EnsEMBL-CORBA interface derived from BioCORBA, a perl EnsEMBL
CORBA server has been written which is accessible to C, Java, and
Python clients, and therefore making the EnsEMBL data and algorithms
programatically available to these languages.

\section{Discussion}

Open Source development has been an extremely successful mechanism in
the creation of the Bioperl toolkit.  Open Source principals encourage
the freely available source code as well as the ability of anyone to
join the project.  Naturally we are somewhat selective in who we grant
commit access to the project code, this is to insure that all new
developers understand and uphold the design principals of the project.

CVS

Collaboration

Multiple Bug finders and helpers

scientific spirit

\subsection{Examples usage}

All these scripts provide below are included in the bioperl toolkit
version 1.0 in the examples directory.

\begin{itemize}
\item Local Index and sequence retrieval

\lstset{
	language=Perl,
	basicstyle=\small,
	stringstyle={},
	}

\begin{scriptsize}
\begin{lstlisting}{}
use Bio::Index::Fasta;
use Bio::SeqIO;
# build the index
my $index = new Bio::Index::Fasta
(-write_flag => 1,
 -filename => 'myseqs.idx');

# use a custom ID parser
$index->id_parser(\&ncbi_idparse); 
$index->make_index('/data/seqs.fa');

# retrieve seqs

my $seqout = new Bio::SeqIO(-format => 'fasta',
                            -fh   => \*STDOUT);

foreach ( qw(NP_009225 YPKA_YERPS)) {
    my $seq = $index->fetch($_);
    # skip if seq not found
    next unless defined $seq; 
    # write it out to STDOUT
    $seqout->write_seq($seq); 
}

sub ncbi_idparse { 
 my ($id) = @_;
 my @ids = split(/\|/,$id);
 my $acc = ($ids[3] =~ /(\S+)\.\d+/);	
 return ( $ids[1],$acc,$ids[3]);	
}
\end{lstlisting}
\end{scriptsize}

\item Sequence retrieval from a Remote Database
\begin{scriptsize}
\begin{lstlisting}{}

use Bio::DB::GenBank;
use Bio::SeqIO;

my $db = new Bio::DB::GenBank();
my $seq = $db->get_Seq_by_acc('NP_009225');
if (defined $seq) {
   $seqout->write_seq($seq);
}
\end{lstlisting}
\end{scriptsize}

\item BLAST \cite{blast} and FastA \cite{fasta} parsing
\begin{scriptsize}
\begin{lstlisting}{}

use Bio::SearchIO;
# Let's parse a NCBI blast XML-ified report  
my $search = new Bio::SearchIO
         (-format => 'blastxml',
          -file   => 'report.xml');
my @HitsToSave;
my $cutoffe = 0.001;
my $cutofflen = 120;
while( my $result = $search->next_result ) {
  printf "query is %s\n", $result->query_name;
  HIT: while( my $hit = $result->next_hit ) {
   printf "hit is %s\n", $hit->name;
   while( my $hsp = $hit->next_hsp ) {
    if( $hsp->evalue < $cutoffe &&
       $hsp->length('total') >= $cutofflen ) 
       {
	    push @HitsToSave, $hit;
	    next HIT;
       } 
   }
  }
}

# now one might process hits that meet criteria
\end{lstlisting}
\end{scriptsize}

\item Extract a subsequence flanking a SNP position
\begin{scriptsize}
\begin{lstlisting}{}
use Bio::PrimarySeq;
use Bio::SeqIO;
use Bio::DB::EMBL;
use strict;

my $acc = 'J00231';       # sequence id
my $snppos = 200;         # position in the sequence
my $flanklen = 50;        # returned sequence 
	                  # length 2*50+1
my $strand = -1;          # reverse strand
my $out_format = 'FASTA'; # output format, 
	                  # going into STDOUT

my ($seq, $out_seq);
eval {
    my $gb = new Bio::DB::EMBL;
    $seq = $gb->get_Seq_by_acc($acc);
};
die "Could not find sequence $acc" if $@;

my $out = Bio::SeqIO->new('-format' => $out_format);

my $five_start = $snppos - $flanklen;
$five_start = 1 if $five_start < 1;
my $three_end = $snppos + $flanklen;
$three_end = $seq->length if ( $snppos + 
$flanklen > $seq->length );

my $five_prime = lc $seq->subseq($five_start, 
                                 $snppos - 1);
my $snp = uc $seq->subseq($snppos, $snppos);
my $three_prime = lc $seq->subseq($snppos + 1, 
                                  $three_end); 
my $locpos = length($five_prime) + 1;

my $fastaid = "$acc oripos=$snppos ".
              "strand=$strand allelepos=$locpos";

if (defined $strand and $strand == -1) {
    my $five_prime_seq = new Bio::PrimarySeq
                         (-seq=>$five_prime);
    my $snp_seq = new Bio::PrimarySeq
	              (-seq=>$snp);
    my $three_prime_seq = new Bio::PrimarySeq
                              (-seq=>$three_prime);

    my $str = $three_prime_seq->revcom->seq. 
              $snp_seq->revcom->seq. 
	      $five_prime_seq->revcom->seq;
    $out_seq = new Bio::PrimarySeq (-id => $fastaid,
				    -seq => $str );
} else {
    my $str = $five_prime. $snp. $three_prime;
    $out_seq = new Bio::PrimarySeq (-id => $fastaid,
				    -seq => $str );
}
$out->write_seq($out_seq);

\end{lstlisting}
\end{scriptsize}

\end{itemize}

\subsubsection{Applications built with Bioperl}

By far the most advanced use of the Bioperl toolkit has come through
the EnsEMBL project.  The basic sequence handling, file format
parsing, and sequence features for annotation model has been tested
through the extensive .

Genquire\cite{genquire}

Generic Model Organism Browser \cite{gmod}

TFBS \cite{tfbs}

Distributed Annotation System perl server Bio::DB::GFF \cite{das,biodbgff}

\subsubsection{Users}

A primary motivation behind writing this toolkit was the authors'
desire to not duplicate effort.  In our minds, once a solution for
parsing and interpreting sequence from Genbank format files is
written, no one else should have to worry about writing their own.  In
this spirit we chose to make our code free....

However, in order for biologists to not worry about writing Genbank
parsers our software has be user friendly.  To that end we've both
provided extensive documentation of all the methods in each module, a
graphical UML diagram of the objects in the toolkit, and a number of
tutorials with examples of common problems.  Additionally we have
written a module Bio::Perl which provides common methods for those who
prefer method based programming rather than object-oriented.

\section{Conclusions}

Open Source development = good.

\section{Acknowledgements}

The Bioperl Core is Jason Stajich, Hilmar Lapp, Heikki Lehvaslaiho,
Lincon Stein, and Ewan Birney.  The project has seen signifigant
contributions from the following people David Block, Kris Boulez,
Steven Brenner, Brad Chapman, Steve Chervitz, Michele Clamp, Tony Cox,
James Cuff, Chris Dagdigian, Andrew Dalke, Allen Day, Arne Elofsson,
Mark Fiers, Georg Fuellen, James Gilbert, Roger Hall, Joseph Insana,
Nicolas Joly, Ian Korf, Aaron Mackey, Brad Marshall, Chad Matsalla,
Chris Mungall, Brian Osborne, Matthew Pockock, Todd Richmond, Martin
Senger, Peter Schattner, Elia Stupka, Gert Thijs, Mark Wilkinson,Alex
Zelensky.

Additional ideas and help from the other Bio{*} project teams
including Jeff Chang, Andrew Dalke, Thomas Down and all of the bioperl
mailing list members.

% ?? Steve Searle
% ?? Ian Holmes
% ?? Helge Weissig

[MOVE ME SOMEWHERE] 
The Bioperl project is a joint effort of many researchers in an
open-source manner.  The Bioperl project and its sister projects
(commonly referred to as the Bio{*} projects) are supported under the
umbrella of the Open Bioinformatics Foundation (OBF)
\url{http://www.open-bio.org}.

The Bioperl team would like to thank Chris Dagdigian for OBF system
administration and primary webmaster.  We would like to acknowledge
hardware donated by Compaq and Sun Microsytems.

\bibliography{bioperl}
\bibliographystyle{bioinformatics} 

\end{document}
