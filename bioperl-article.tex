\documentclass{article}
% conventions -
%
% Interfaces are in italics
% Module names in Bold
% method names in bold italics
%
% when describing the bioperl objects, list all
% the applicable interfaces and objects at the beginning
% of the subsection like
% Objects: Object1 Object2
% Interfaces: Interface1 Interface2

% Things that have not been discussed

\usepackage {
 fullpage,fancyheadings,lscape,rotating,
 float,longtable,epsfig,psfig,layouts, bioinformatics
}

\begin{document}

\begin{twocolumn}
\title{The Bioperl Toolkit}
% Not sure how to do this - some people should be in the title?
\author{The Bioperl Core, http://www.bioperl.org }
\maketitle

\begin{abstract}

\textbf{Motivation:} Perl is by far the most widely used programming
language in various domains of bioinformatics, which is commonly
attributed to the language being grasped quickly even by newcomers to
the field, and to Perl's many text-processing features.  Programming in
Perl has been extremely successful for glueing together programs into
pipelines, converting between different formats, and extracting the
desired information from the output of analysis programs.  However, a
significant part of the code of Perl Bioinformatics applications, and
consequently of the development time spent, consists of re-occurring
tasks, leading to a high extent of code duplication in the
Bioinformatics community.  Perl programmers in the field are often
unfamiliar with software engineering concepts directed at alleviating
the problem, like generic modules re-used by specific applications, or
the overhead incurred by generalizing the program flow into re-usable
components is considered prohibitive.

\textbf{ Results:} Here we report about the Bioperl project, which is
an international open-source collaboration of biologists,
bioinformaticists, and computer scientists that has evolved over the
last 5 years into the most comprehensive library of object-oriented
Perl modules for manipulating and managing life science information.
BioPerl provides an easy-to-use, mature, stable, and consistent
programming interface to bioinformatics application programmers.
BioPerl has been successfully used to achieve otherwise complex tasks
with only few lines of code.  We report about the object and data
model we conceived to represent various entities one frequently has to
deal with in the bioinformatics domain.  The BioPerl object model has
been proven to be flexible enough to build enterprise-level
applications like EnsEMBL \cite{ensembl} on top of it, while at the
same time keeping a shallow learning curve even for inexperienced Perl
programmers.  BioPerl is also capable of interoperating with other
programming languages like Python and Java through the evolving
BioCORBA bridge.

{\bf Availability:} BioPerl is available as open-source software free
of charge at http://www.bioperl.org/.

\end{abstract}

\section{Introduction}

At the time of inception of BioPerl in 1995 \cite{Fullen1995}
there were only few programmimg toolkits for manipulating biological
data and results from sequence analysis programs, and there were in
fact none available in Perl \cite{Wall2000}, a scripting language that
quickly gained widespread popularity in the bioinformatics community
for its efficient support of all sorts of text processing tasks, and
because neophyte computer programming biologists without a background
in computer science could easily grasp the language.

While most compute-intensive analysis algorithms are implemented as
stand-alone programs in compiled languages like C for efficiency
reasons, putting together analysis pipelines for automating the tasks
of launching external programs, extracting results, and passing on
information to downstream programs requires mostly text-processing
facilities and convenient data structures.

Programming such tasks in Perl added powerful yet easy-to-learn
constructs for text-processing and information extraction as compared
to writing scripts that feed the output of one program to the next one
using packages understanding a common file format, e.g., the GCG
package \cite{Devereux1984}.  Such toolkits bear the difficulty that they
require an intimate knowledge of the programs' parameters, and how
they have to be changed to achieve the desired behaviour.  Scripts were
inherently dependent on the particular program being run, not only on
the kind of algorithm.  The output from different analysis programs for
the same purpose, like different alignment programs, represented
similar information but in different formats.  Hence it was impossible
to create generic scripts treating external programs as pluggable
components.

The Bioperl project grew out of the following observations.  First,
even though file formats of different analysis programs are different,
the represented information is the same.  E.g., a pair-wise alignment
is always between two sequences and has common properties, like
length, score, fraction of identities, start and end on both
sequences, etc. 

Second, the number of data structures needed to represent the
information flow is limited, and common to most applications, like
sequences, annotation, features, and alignments.  The language Perl
itself has no native way of defining abstract data types, unlike
e.g. C.

Third, a large number of operations performed are common between
applications, like parsing a data entity out of an input stream,
writing manipulated entities, filtering a stream of data entities to
screen for certain criteria, etc. 

This scenario naturally lends itself to the principle of object
oriented programming, which Perl emulates by modules.  A module
corresponds to the notion of a `class' in object-oriented languages.
Hence, the mission of BioPerl is to provide an easy-to-use
object-oriented Perl library that encapsulates data structures and
operations commonly used in the life sciences as clean, generic, and
re-usable modules.  The goal is that an application programmer using
BioPerl can focus on the problems specific to his or her application,
because BioPerl provides ready-to-use solutions for the those data
types and operations common to life science informatics.  In addition,
we set out to design a data and object model that is easy to learn
even for Perl neophytes, and at the same time flexible enough to build
applications up to enterprise-level software.

Over time BioPerl has evolved into the most comprehensive toolkit for
bioinformatics in Perl.  The programming interface is stable.  Our
recent release of version 1.0 underlines its maturity.  In this paper
we report about BioPerl as of its production release 1.0.

The rest of the paper is organized as follows.  First we describe the
data and object model we conceived, followed by an elaboration on
BioPerl's interoperability with bioinformatics toolkits written in
other programming languages.  Subsequently we discuss the strengths and
deficiencies of the design and the implementation of the library, also
with respect to other packages available in the field.  We conclude
with a summary of the key benefits of the toolkit for the Perl
bioinformatics programming community.

\section{Systems and Methods}

BioPerl itself is written purely in Perl and requires at least version
5.005 of the Perl interpreter being installed.  The toolkit has been
checked for cross-platform compatibility on different flavours of Unix
including MacOS X as well as on Win32 systems (both NT and Win98) and
MacOS [FIXME is this all correct?].  So far we have not encountered any
incompatibilities on the Unix platforms [FIXME maybe we should list
some here] we tested.  [FIXME Rework when we know complete story about
what does/doesn't work on Mac/Win] On the MacOS and Win32 platforms
the great majority of the modules in the toolkit run without
problems.  However, some modules having external dependencies either as
Perl modules with possibly compiled code, or as external programs they
encapsulate don't work on these platforms due to problems in the
external dependencies.

One module for protein sequence Smith-Waterman alignments requires an
additional package with compiled C-code to be installed that computes
the alignment much more efficiently than could be done in
Perl.  Installing this module is, however, optional.

\section{Object and Data Model}

At present the objects and operations in BioPerl center around
biological sequence analysis and annotation.  Genomic sequencing
projects have been one of the primary use cases for building analysis
pipelines and database interfaces on top of BioPerl. 

\subsection{Object hierarchy}

BioPerl's object hierarchy covers the following aspects.
\begin{itemize}
\item Sequences and their properties.
\item Sequence input/output.  BioPerl provides a generic driver
manager, which instantiates the appropriate driver, depending on a
user-specified file format, or inferred from the extension of an input
file name.  The driver itself always returns a stream of sequence
objects.  Currently there are drivers for FASTA, EMBL, Genbank, SwissProt,
Ace, GCG, SCF, GAME, BSML, and raw format.
\item Sequence database indexing and retrieval. 
\item Feature representation and annotation.
\item Generic annotation.
\item Multiple alignment representation and input/output.
\item Sequence variations and mutations.
\item Parser for sequence analysis tools.
\item Phylogenetic trees
\item Protein structure data
\item Generic biological maps (genetic, physical)
\item Distributed Annotation Sever (DAS) toolkit and database
\end{itemize}

\subsection{Design principles}

When designing the library's object hierarchy our objective was to
provide a programming interface that is very easy to use, but that at
the same time can be easily extended in its capabilities and behaviour
through code-reuse.  While object-oriented programming naturally lends
itself to code-reuse through the principle of inheritance, to make
this work in practice for more than very simple cases it is wise to
observe certain design principles. 

\begin{itemize}

\item Separating the interface from the implementation.  The key
information about an object for a client calling its methods is the
method prototypes, making up the API of the particular class.  By
putting this API into its own module, called an interface, the actual
implementation can be provided from the library itself just as well as
from a user of the library, even in another language.  There is no risk
of interfering with certain implementation specific details as
compared to inheriting from a full implementation.

% Can someone describe this in a better way?

\item Using factories for object creation.  Certain modules need to
create other objects of the library, or more precisely, instantiate
implementations of other interfaces, in order to accomplish their
task.  For example, a sequence input driver needs to instantiate
sequence objects from the input information.  If the actual class to be
instantiated is hard-coded in the module, a client providing his or
her own implementation of the required interface cannot ask the
library to instantiate his implementation instead of that the library
provides.  Factories solve this problem; objects to be created are
obtained from a factory object, and a client can provide his own
factory object that would instantiate his own classes.

\end{itemize}

In BioPerl we followed these two design principles [Shall we call this
`design patterns' instead?] throughout the library wherever
possible.  Most classes come as an interface, with a capital 'I'
appended to the object name (e.g., Bio::SeqI and Bio::Seq), together
with a ready-to-use fully functional implementation.  [A good example
for the factory pattern should follow once we have it.]

\section{Interoperability}

% Need help cutting down

While Perl is an ideal language for both novice and experienced
programmers and bioinformatics specialists one may want to take
advantage of the properties of other languages such as the graphical
capabilities of java or speed of C programs.  Numerous methods are
possible for utilizing other languages depending on where one wanted
to partition the problem and build layers into a system.  Database
layers provide data abstraction while network layers can provide
process abstraction.  These partitioning of data, objects, or
processes is a powerful means for leveraging resources in different
environments.  Typically this is easier done by communicating through
a standard.  

The Extensible Markup Language (XML) provides a means for creating
data in a language and platform independent manner.  Previous work has
outlined scenarios where XML has been useful in a biological context
\cite{xml_bioinformatics}.  

The Common Object Request Broker Architecture (CORBA) allows a
programmer to develop client/server applications in different
languages and to build components of a program, or objects in separate
languages.  These objects live in the space of a running process on a
machine, but a programmer can execute methods on objects on different
machines, even written in a different language. CORBA was designed
with distributed objects as the primary goal, however we can take
advantage of this technology to create applications which utilize
objects written in different languages to take advantage of that
language functionality.

This cross-language interoperability is leveraged by creating a common
set of object interface definitions, written for CORBA in the
Interface Design Language (IDL).  IDL is a multi-purpose way to create
interface definitions and is useful for describing the minimal set of
method or data objects must have.  Once this contract for interfaces
has been established developers can implement the interfaces and
provide services which utilize these objects. 

For example, the bioperl project has created a robust set of sequence
parsing routines which a C programmer may want to take advantage of
rather than writing their own parser from scratch.  However C is a
more optimal language for predicting secondary structure of an RNA
sequence or calculating sequence overlaps in a contig assembly.  By
utilizing CORBA, C code can be written to simply obtain a sequence
object and query the object for the sequence bases as a string, and
apply an algorithm calculating minimal energy.  Similarly if one was
interested in integrating analysis from a new dynamic programming
toolkit written in Java into a perl based application, the necessary
components can be accessed through an interface and the CORBA layer.

The BioCORBA project is a sister project of BioPerl coordinated with
BioJava and BioPython which has developed a standard IDL describing
biological data.  Collaboration between the BioCORBA and Object
Management Group's Life Science Research group has yielded a joint IDL
useful for the scope of sequence analysis which will become the
standard BioCORBA IDL \cite{biocorba}.

This interoperability has also been applied to the EnsEMBL project.
The current version of EnsEMBL (1.1) is written primarily in Perl
which easily integrating EnsEMBL functionality into python, Java, or C
code.  With an EnsEMBL-CORBA interface derived from BioCORBA, a
developer can build applications utilizing objects from EnsEMBL.

\section{Discussion}

Open Source development has been an extremely successful mechanism in
the creation of the Bioperl toolkit.  
integrating biological researchers with computational applications of
their research. 

\subsection{Examples}

\subsubsection{Short Scripts}
\begin{itemize}
\item Local Index and sequence retrieval

\begin{verbatim}
use Bio::Index::Fasta;
use Bio::SeqIO;
# build the index
my $index = new Bio::Index::Fasta(-write_flag => 1,
				  -filename   => 'nr.idx');

$index->id_parser(\&ncbi_idparse); # use a custom ID parser
$index->make_index('/data/seqs.fa');

# retrieve seqs

my $seqout = new Bio::SeqIO(-format => 'fasta',
			    -fh   => \*STDOUT);

foreach ( qw(NP_009225 YPKA_YERPS)) {
    my $seq = $index->fetch($_);
    next unless defined $seq; # skip if seq not found
    $seqout->write_seq($seq); # write it out to the screen
}

sub ncbi_idparse { 
 my ($id) = @_;
 my @ids = split(/\|/,$id);
 my $acc = ($ids[3] =~ /(\S+)\.\d+/);	
 return ( $ids[1],$acc,$ids[3]);	
}
\end{verbatim}

\item Remote db retrieval

\begin{verbatim}
use Bio::DB::GenBank;

my $db = new Bio::DB::GenBank();
my $seq = $db->get_Seq_by_acc('NP_009225');
my $seqout = new Bio::SeqIO(-format => 'genbank,
			    -fh   => \*STDOUT);
$seqout->write_seq($seq) if defined $seq;
\end{verbatim}

\item Heikki's get flanking seq for SNP stuff

\end{itemize}

\subsubsection{EnsEMBL}

By far the most advanced use of the Bioperl toolkit has come through
the EnsEMBL project.  The basic sequence handling, file format
parsing, and sequence features for annotation model has been tested
through the extensive .

[FIXME: EWAN to help outline better here]


\section{Conclusions}

\section{Acknowledgements}

The Bioperl Core is Jason Stajich, Hilmar Lapp, Heikki Lehvaslaiho,
and Ewan Birney.  The project has seen signifigant
contributions from the following people David Block, Kris Boulez
Steven Brenner, Brad Chapman, Steve Chervitz, Michele Clamp, Chris
Dagdigian, Andrew Dalke, Allen Day, Arne Elofsson, Mark Fiers, Georg
Fuellen, James Gilbert, Roger Hall, Ian Holmes, Joseph Insana, Nicolas
Joly, Ian Korf, Aaron Mackey, Brad Marshall, Chad Matsalla, Chris
Mungall, Matthew Pockock, Todd Richmond, Peter Schattner, Lincoln
Stein, Elia Stupka, Gert Thijs, Mark Wilkinson, Helge Weissig, Alex
Zelensky.

 
[FIXME do we announce Open Bioinformatics Foundation here as well?]
The Bioperl project is a joint effort of many researchers in an
open-source manner.  Our list of contributing authors is available
from our website [and included here?]. 

The Bioperl team would like to thank Chris Dagdigian for his system
administration of the OBF computers .  We would like to acknowledge
hardware donated by Compaq and Sun Microsytems...

\bibliography{bioperl}
\bibliographystyle{bioinformatics} 

\end{twocolumn}

\end{document}
