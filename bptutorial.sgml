<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.1//EN" >
<!-- -->
<!-- $Id: bptutorial.sgml,v 1.1 2002-07-29 20:03:36 jason Exp $ -->
<!-- -->
<!-- $Log: not supported by cvs2svn $ -->
<!-- -->
<!-- General reminders: -->

<book>

<chapter id="pod2docbook-ch-1"><title>BioPerlTutorial - a tutorial for bioperl

</title>

<para>
BioPerlTutorial - a tutorial for bioperl
This document is available as HTML at
http://www.bioperl.org/Core/bptutorial.html and as 'bptutorial.pl' in
the Bioperl distribution.

</para>

<sect1 id="pod2docbook-ch-1-sect-1"><title>AUTHOR

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
<screen>
  Cared for by Peter Schattner &lt;schattner@alum.mit.edu&gt;
</screen>


</para>

<para>
<screen>
  Copyright Peter Schattner
</screen>


</para>

<para>
<screen>
  Contributions, additions and corrections have been made
  to this document by the following individuals:
</screen>


</para>

<para>
<screen>
  Jason Stajich
  Heikki Lehvaslaiho
  Brian Osborne
  Hilmar Lapp
  Chris Dagdigian
</screen>


</para>

</sect1>

<sect1 id="pod2docbook-ch-1-sect-2"><title>DESCRIPTION

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
<screen>
   This tutorial includes "snippets" of code and text from various
   Bioperl documents including module documentation, example scripts
   and "t" test scripts. You may distribute this tutorial under the
   same terms as perl itself.
</screen>


</para>

<para>
<screen>
   This document is written in Perl POD (plain old documentation)
   format.  You can run this file through your favorite pod translator
   (pod2html, pod2man, pod2text, etc.) if you would like a more
   convenient formatting.
</screen>


</para>

<para>
<screen>
  Table of Contents
</screen>


</para>

<para>
<screen>
  I. Introduction
  I.1 Overview
  I.2 Software requirements
    I.2.1 For minimal bioperl installation
    I.2.2 For complete installation
  I.3 Installation procedures
  I.4 Additional comments for non-unix users
</screen>


</para>

<para>
<screen>
  II. Brief overview to bioperl's objects
  II.1 Sequence objects:
         (Seq, PrimarySeq, LocatableSeq, LiveSeq, LargeSeq, RichSeq, SeqWithQuality, SeqI)
  II.2 Alignment objects (SimpleAlign)
  II.3  Location objects (Simple, Split, Fuzzy)
  II.4  Interface objects and implementation objects
</screen>


</para>

<para>
<screen>
  III. Using bioperl
  III.1 Accessing sequence data from local and remote databases
     III.1.1 Accessing remote databases (Bio::DB::GenBank, etc)
     III.1.2 Indexing and accessing local databases (Bio::Index::*,  bpindex.pl,  bpfetch.pl)
  III.2 Transforming formats of database/ file records
     III.2.1 Transforming sequence files (SeqIO)
     III.2.2 Transforming alignment files (AlignIO)
  III.3 Manipulating sequences
    III.3.1 Manipulating sequence data with Seq methods (Seq)
    III.3.2 Obtaining basic sequence statistics- MW, residue &amp;codon frequencies (SeqStats)
    III.3.3 Identifying restriction enzyme sites (RestrictionEnzyme)
    III.3.4 Identifying amino acid cleavage sites (Sigcleave)
    III.3.5 Miscellaneous sequence utilities: OddCodes, SeqPattern
    III.3.6 Sequence manipulation using the Bioperl EMBOSS interface
    III.3.7 Sequence manipulation without creating Bioperl "objects"
  III.4 Searching for "similar" sequences
     III.4.1 Running BLAST locally  (StandAloneBlast)
     III.4.2 Running BLAST remotely (using RemoteBlast.pm)
     III.4.3 Parsing BLAST and FASTA reports with Search and SearchIO
     III.4.4 Parsing BLAST reports with BPlite, BPpsilite, BPbl2seq and Blast.pm
     III.4.5 Parsing HMM reports (HMMER::Results)
  III.5 Creating and manipulating sequence alignments
     III.5.1 Aligning 2 sequences with Smith-Waterman (pSW)
     III.5.2 Aligning 2 sequences with Blast using  bl2seq and AlignIO
     III.5.3 Aligning multiple sequences (Clustalw.pm, TCoffee.pm)
     III.5.4 Manipulating and displaying alignments (SimpleAlign)
  III.6 Searching for genes and other structures on genomic DNA
                        (Genscan, Sim4, ESTScan, MZEF, Grail, Genemark, EPCR)
  III.7 Developing machine readable sequence annotations
     III.7.1 Representing sequence annotations (Annotation, SeqFeature, RichSeq)
     III.7.2 Representing and large and/or changing sequences (LiveSeq,LargeSeq)
     III.7.3 Representing related sequences - mutations, polymorphisms etc (Allele, SeqDiff)
     III.7.4 Incorpotating quality data in sequence annotation (SeqWithQuality)
     III.7.5 Sequence XML representations - generation and parsing (SeqIO::game)
  III.8 Representing non-sequence data in Bioperl: structures, trees, maps, graphics and bibliographic text
     III.8.1 Using 3D structure objects and reading PDB files (StructureI, Structure::IO)
     III.8.2 Tree objects and phylogenetic trees (Tree::Tree, TreeIO)
     III.8.3 Map objects for manipulating genetic maps (Map::MapI, MapIO)
     III.8.4 Bibliographic objects for querying bibliographic databases (Biblio)
     III.8.5 Graphics objects for representing sequence objects as images (Graphics)
</screen>


</para>

<para>
<screen>
  III.9 Bioperl alphabets
     III.9.1 Extended DNA / RNA alphabet
     III.9.2 Amino Acid alphabet
</screen>


</para>

<para>
<screen>
  IV.  Related projects - biocorba, biopython, biojava, EMBOSS, Ensembl, GFF, Genquire
     IV.1 Biocorba
     IV.2 Biopython and biojava
     IV.3 EMBOSS
     IV.4 Ensembl and bioperl-db
     IV.5 GFF format and Bio::DB::GFF*
     IV.6 Genquire, the Annotation Workbench and bioperl-gui
</screen>


</para>

<para>
<screen>
  V.  Appendices
     V.1 Finding out which methods are used by which Bioperl Objects
     V.2 Tutorial Demo Scripts
</screen>


</para>

</sect1>

<sect1 id="pod2docbook-ch-1-sect-3"><title>I. Introduction

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<sect2 id="pod2docbook-ch-1-sect-3-a"><title>I.1 Overview

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Bioperl is a collection of perl modules that facilitate the development of
perl scripts for bioinformatics applications. As such, it does not include
ready to use programs in the sense that many commercial packages and free
web-based interfaces (eg Entrez, SRS) do. On the other hand, bioperl does
provide reusable perl modules that facilitate writing perl scripts for
sequence manipulation, accessing of databases using a range of data formats
and execution and parsing of the results of various molecular biology
programs including Blast, clustalw, TCoffee, genscan, ESTscan and HMMER.
Consequently, bioperl enables developing scripts that can analyze large
quantities of sequence data in ways that are typically difficult or
impossible with web based systems.


</para>

<para>
In order to take advantage of bioperl, the user needs a basic understanding
of the perl programming language including an understanding of how to use
perl references, modules, objects and methods. If these concepts are
unfamiliar the user is referred to any of the various introductory /
intermediate books on perl. (I've liked S. Holzmer's Perl Core Language,
Coriolis Technology Press, for example). This tutorial is not intended to
teach the fundamentals of perl to those with little or no experience in the
perl language. On the other hand, advanced knowledge of perl - such as how
to write a perl object - is not required for successfully using bioperl.


</para>

<para>
Bioperl is open source software that is still under active development. The
advantages of open source software are well known. They include the ability
to freely examine and modify source code and exemption from software
licensing fees. However, since open source software is typically developed
by a large number of volunteer programmers, the resulting code is often not
as clearly organized and its user interface not as standardized as in a
mature commercial product. In addition, in any project under active
development, documentation may not keep up with the development of new
features. Consequently the learning curve for actively developed, open
source source software is sometimes steep.


</para>

<para>
This tutorial is intended to ease the learning curve for new users of
bioperl. To that end the tutorial includes:


</para>

<itemizedList>
<listitem><para>
</para>

<para>
Descriptions of what bioinformatics tasks can be handled with bioperl


</para>

</listitem>
<listitem><para>
</para>

<para>
Directions on where to find the methods to accomplish these tasks within
the bioperl package


</para>

</listitem>
<listitem><para>
</para>

<para>
Recommendations on where to go for additional information.


</para>

</listitem>
<listitem><para>
</para>

<para>
The POD documentation should contain runnable code in the SYNOPSIS section
which is meant to illustrate the use of a module and its methods.


</para>

</listitem></itemizedList>

<para>
Running the tutorial.pl script while going through this tutorial - or
better yet, stepping through it with an interactive debugger - is a good
way of learning bioperl. The tutorial script is also a good place from
which to cut-and-paste code for your <literal>scripts(rather</literal> than
using the code snippets in this tutorial). The tutorial script should work
on your machine - and if it doesn't it would probably be a good idea to
find out why, before getting too involved with bioperl!


</para>

<para>
This tutorial does not intend to be a comprehensive description of all the
objects and methods available in bioperl. For that the reader is directed
to the documentation included with each of the modules. A very useful
interface for finding one's way within all the module documentation can be
found at http://doc.bioperl.org/bioperl-live/. This interface lists all
bioperl modules and descriptions of all of their methods.


</para>

<para>
One potential problem in locating the correct documentation is that
multiple methods in different modules may all share the same name.
Moreover, because of perl's complex method of ``inheritance'', it is not
often clear which of the identically named methods is being called by a
given object. One way to resolve this question is by using the software
described in Appendix V.1.


</para>

<para>
For those who prefer more visual descriptions,
http://bioperl.org/Core/Latest/modules.html also offers links to three PDF
files which contain schematics that describe how many of the bioperl
objects related to one another.


</para>

<para>
In addition, a bioperl online course is available on the web at
http://www.pasteur.fr/recherche/unites/sis/formation/bioperl. The user is
also referred to numerous bioperl scripts in the scripts/ and examples/
directories (see bioperl.pod for a description of all these scripts).


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-3-b"><title>I.2 Software requirements

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


</sect2>

<sect2 id="pod2docbook-ch-1-sect-3-c"><title>I.2.1 Minimal bioperl installation

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
For a ``minimal'' installation of bioperl, you will need to have perl
itself installed as well as the bioperl ``core modules''. Bioperl has been
tested primarily using perl 5.005 and perl 5.6. The minimal bioperl
installation should still work under perl 5.004. However, as increasing
numbers of bioperl objects are using modules from CPAN (see below),
problems have been observed for bioperl running under perl 5.004. So if you
are having trouble running bioperl under perl 5.004, you should probably
upgrade your version of perl.


</para>

<para>
In addition to a current version of perl, the new user of bioperl is
encouraged to have access to, and familiarity with, an interactive perl
debugger. Bioperl is a large collection of complex interacting software
objects. Stepping through a script with an interactive debugger is a very
helpful way of seeing what is happening in such a complex software system -
especially when the software is not behaving in the way that you expect.
The free graphical debugger ptkdb (available as Devel::ptkdb from CPAN) is
highly recommended. Active State, from http://www.activestate.com, offers a
commercial graphical debugger for windows systems. The standard perl
distribution also contains a powerful interactive debugger - though with a
more cumbersome (command line) interface. The Perl tool Data::Dumper used
with the syntax:


</para>

<para>
<screen>
  use Data::Dumper;
  printer Dumper($seq);
</screen>


</para>

<para>
can also be helpful for obtaining debugging information on perl objects.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-3-d"><title>I.2.2 Complete installation

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Taking full advantage of bioperl requires software beyond that for the
minimal installation. This additional software includes perl modules from
CPAN, bioperl perl extensions, a bioperl xs-extension, and several standard
compiled bioinformatics programs.


</para>

<para>
<emphasis>Perl - extensions</emphasis>




</para>

<para>
The following perl modules are available from bioperl,
http://bioperl.org/Core/external.shtml, or from CPAN,
http://www.perl.com/CPAN/, and are used by bioperl. The listing also
indicates what bioperl features will not be available if the corresponding
CPAN module is not downloaded. If these modules are not available (eg
non-unix operating systems), the remainder of bioperl should still function
correctly.


</para>

<para>
For accessing remote databases you will need:


</para>

<itemizedList>
<listitem><para>
</para>

<para>
File-Temp-0.09


</para>

</listitem>
<listitem><para>
</para>

<para>
IO-String-1.01


</para>

</listitem></itemizedList>

<para>
For accessing Ace databases you will need:


</para>

<itemizedList>
<listitem><para>
</para>

<para>
AcePerl-1.68.


</para>

</listitem></itemizedList>

<para>
For remote blast searches you will need:


</para>

<itemizedList>
<listitem><para>
</para>

<para>
libwww-perl-5.48


</para>

</listitem>
<listitem><para>
</para>

<para>
Digest-MD5-2.12.


</para>

</listitem>
<listitem><para>
</para>

<para>
HTML-Parser-3.13


</para>

</listitem>
<listitem><para>
</para>

<para>
libnet-1.0703


</para>

</listitem>
<listitem><para>
</para>

<para>
MIME-Base64-2.11


</para>

</listitem>
<listitem><para>
</para>

<para>
URI-1.09


</para>

</listitem>
<listitem><para>
</para>

<para>
IO-stringy-1.216


</para>

</listitem></itemizedList>

<para>
For xml parsing you will need:


</para>

<itemizedList>
<listitem><para>
</para>

<para>
libxml-perl-0.07


</para>

</listitem>
<listitem><para>
</para>

<para>
XML-Parser-2.30


</para>

</listitem>
<listitem><para>
</para>

<para>
XML-Twig-2.02


</para>

</listitem>
<listitem><para>
</para>

<para>
XML-Writer-0.4


</para>

</listitem>
<listitem><para>
</para>

<para>
Soap-Lite-0.52


</para>

</listitem>
<listitem><para>
</para>

<para>
XML-DOM-1.37


</para>

</listitem>
<listitem><para>
</para>

<para>
expat-1.95.1 from http://sourceforge.net/projects/expat/


</para>

</listitem></itemizedList>

<para>
For more current and additional information on external modules required by
bioperl, check http://bioperl.org/Core/external.shtml


</para>

<para>
<emphasis>Bioperl C extensions & external bioinformatics programs</emphasis>




</para>

<para>
Bioperl also uses several C programs for sequence alignment and local blast
searching. To use these features of bioperl you will need an ANSI C or Gnu
C compiler as well as the actual program available from sources such as:


</para>

<para>
for Smith-Waterman alignments- bioperl-ext-0.6 from
http://bioperl.org/Core/external.shtml


</para>

<para>
for clustalw alignments- ftp://ftp-igbmc.u-strasbg.fr/pub/ClustalW/


</para>

<para>
for tcoffee alignments-
http://igs-server.cnrs-mrs.fr/~cnotred/Projects_home_page/t_coffee_home_page.html



</para>

<para>
for local blast searching-
ftp://ftp.ncbi.nlm.nih.gov/blast/server/current_release/


</para>

<para>
for EMBOSS applications -
http://www.hgmp.mrc.ac.uk/Software/EMBOSS/download.html


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-3-e"><title>I.3 Installation

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
The actual installation of the various system components is accomplished in
the standard manner:


</para>

<itemizedList>
<listitem><para>
</para>

<para>
Locate the package on the network


</para>

</listitem>
<listitem><para>
</para>

<para>
Download


</para>

</listitem>
<listitem><para>
</para>

<para>
Decompress (with gunzip or a similiar utility)


</para>

</listitem>
<listitem><para>
</para>

<para>
Remove the file archive (eg with tar -xvf)


</para>

</listitem>
<listitem><para>
</para>

<para>
Create a ``makefile'' (with ``perl Makefile.PL'' for perl modules or a
supplied ``install'' or ``configure'' program for non-perl program


</para>

</listitem>
<listitem><para>
</para>

<para>
Run ``make'', ``make test'' and ``make install'' This procedure must be
repeated for every CPAN module, bioperl-extension and external module to be
installed. A helper module CPAN.pm is available from CPAN which automates
the process for installing the perl modules.


</para>

<para>
The CPAN module can also be used to install all of the modules listed above
in a single step as a ``bundle'' of modules, Bundle::BioPerl, eg


</para>

<para>
<screen>
  $&gt;perl -MCPAN -e shell
  cpan&gt;install Bundle::BioPerl
  &lt;installation details....&gt;
  cpan&gt;install B/BI/BIRNEY/bioperl-1.0.tar.gz
  &lt;installation details....&gt;
  cpan&gt;quit
</screen>


</para>

<para>
The disadvantage of this approach is that if there's a problem installing
any individual module it may be a bit more difficult to address.


</para>

</listitem></itemizedList>

<para>
For the external programs (clustal, Tcoffee, ncbi-blast), there is an extra
step:


</para>

<itemizedList>
<listitem><para>
</para>

<para>
Set the relevant environmental variable (CLUSTALDIR, TCOFFEEDIR or
BLASTDIR) to the directory holding the executable in your startup file - eg
in .bashrc. (For running local blasts, it is also necessary that the name
of local-blast database directory is known to bioperl. This will typically
happen automatically, but in case of difficulty, refer to the documentation
in
<emphasis>Bio</emphasis>)


</para>

</listitem></itemizedList>

<para>
The only likely complication (at least on unix systems) that may occur is
if you are unable to obtain system level writing privileges. For
instructions on modifying the installation in this case and for more
details on the overall installation procedure, see the README file in the
bioperl distribution as well as the README files in the external programs
you want to use (eg bioperl-ext, clustalw, TCoffee, NCBI-blast).


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-3-f"><title>I.4 Additional comments for non-unix users

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Bioperl has mainly been developed and tested under various unix
environments (including Linux) and this tutorial is intended primarily for
unix users. The minimal installation of bioperl should work under other
OS's (NT, windows,Mac). However, bioperl has not been widely tested under
these OS's.


</para>

<para>
Todd Richmond has written of his experiences with BioPerl on MacOS 9 at
http://bioperl.org/Core/mac-bioperl.html. There is also a description of
bioperl on windows by Jurgen Pletinckx at
http://www.bioperl.org/Core/windows-bioperl.html. (Note that currently
these documents describe release 0.7.x of bioperl.) Minimal bioperl does
run without problems on Mac OS X since it is a Unix system. However,
external precompiled programs (eg NCBI local Blast) and other useful
auxiliary programs such as perl-TK and ptkdb are in many cases not yet
available under OS X.


</para>

<para>
Steve Cannon has compiled installation notes and suggestions for Bioperl on
OS X online at http://www.tc.umn.edu/~cann0010/Bioperl_OSX_install.html.


</para>

<para>
Many bioperl features require the use of CPAN modules, compiled extensions
or external programs. These features will probably will not work under some
or all of these other operating systems. If a script attempts to access
these features from a non-unix OS, bioperl is designed to simply report
that the desired capability is not available. However, since the testing of
bioperl in these environments has been limited, the script may well crash
in a less ``graceful'' manner.


</para>

</sect2>

</sect1>

<sect1 id="pod2docbook-ch-1-sect-4"><title>II. Brief introduction to bioperl's objects

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
The purpose of this tutorial is to get you using bioperl to solve real-life
bioinformatics problems as quickly as possible. The aim is not to explain
the structure of bioperl objects or perl object-oriented programming in
general. Indeed, the relationships among the bioperl objects is not simple;
however, understanding them in detail is fortunately not necessary for
successfully using the package.


</para>

<para>
Nevertheless, a little familiarity with the bioperl object ``bestiary'' can
be very helpful even to the casual user of bioperl. For example there are
(at least) seven different ``sequence objects'' - Seq, PrimarySeq,
LocatableSeq, LiveSeq, LargeSeq, SeqI, and SeqWithQuality. Understanding
the relationships among these objects - and why there are so many of them -
will help you select the appropriate one to use in your script.


</para>

<sect2 id="pod2docbook-ch-1-sect-4-a"><title>II.1 Sequence objects: (Seq, RichSeq, SeqWithQuality, PrimarySeq, LocatableSeq, LiveSeq, LargeSeq, SeqI)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Seq is the central sequence object in bioperl. When in doubt this is
probably the object that you want to use to describe a DNA, RNA or protein
sequence in bioperl. Most common sequence manipulations can be performed
with Seq. These capabilities are described in sections
<emphasis>III.3.1</emphasis> and <emphasis>III.7.1</emphasis>, or in <emphasis>Bio</emphasis>.


</para>

<para>
Seq objects can be created explicitly (see section <emphasis>III.2.1</emphasis> for an example). However usually Seq objects will be created for you
automatically when you read in a file containing sequence data using the
SeqIO object. This procedure is described in section <emphasis>III.2.1</emphasis>. In addition to storing its identification labels and the sequence itself,
a Seq object can store multiple annotations and associated ``sequence
features''. This capability can be very useful - especially in development
of automated genome annotation systems, see section
<emphasis>III.7.1</emphasis>.


</para>

<para>
RichSeq objects store additional annotations beyond those used by standard
Seq objects. If you are using sources with very rich sequence annotation,
you may want to consider using these objects which are described in section <emphasis>III.7.1</emphasis>. SeqWithQuality objects are used to manipulate sequences with quality
data, like those produced by phred. These objects are described in section <emphasis>III.7.4</emphasis>,
<emphasis>Bio</emphasis>, and in <emphasis>Bio</emphasis>.


</para>

<para>
On the other hand, if you need a script capable of simultaneously handling
many (hundreds or thousands) sequences at a time, then the overhead of
adding annotations to each sequence can be significant. For such
applications, you will want to use the PrimarySeq object. PrimarySeq is
basically a ``stripped down'' version of Seq. It contains just the sequence
data itself and a few identifying labels (id, accession number, molecule
type = dna, rna, or protein). For applications with hundreds or thousands
or sequences, using PrimarySeq objects can significantly speed up program
execution and decrease the amount of RAM the program requires. See <emphasis>Bio</emphasis> for more details.


</para>

<para>
What is (for historical reasons) called a LocatableSeq object might be more
appropriately called an ``AlignedSeq'' object. It is a Seq object which is
part of a multiple sequence alignment. It has ``start'' and ``end''
positions indicating from where in a larger sequence it may have been
extracted. It also may have ``gap'' symbols corresponding to the alignment
to which it belongs. It is used by the alignment object SimpleAlign and
other modules that use SimpleAlign objects (eg AlignIO.pm, pSW.pm). In
general you don't have to worry about creating LocatableSeq objects because
they will be made for you automatically when you create an alignment (using
pSW, Clustalw, Tcoffee or bl2seq) or when you input an alignment data file
using AlignIO. However if you need to input a sequence alignment by hand
(eg to build a SimpleAlign object), you will need to input the sequences as
LocatableSeqs. Other sources of information include <emphasis>Bio</emphasis>,
<emphasis>Bio</emphasis>, <emphasis>Bio</emphasis>, and <emphasis>Bio</emphasis>.


</para>

<para>
A LargeSeq object is a special type of Seq object used for handling very
long ( eg &gt; 100 MB) sequences. If you need to manipulate such long sequences see
section <emphasis>III.7.2</emphasis> which describes LargeSeq objects, or <emphasis>Bio</emphasis>.


</para>

<para>
A LiveSeq object is another specialized object for storing sequence data.
LiveSeq addresses the problem of features whose location on a sequence
changes over time. This can happen, for example, when sequence feature
objects are used to store gene locations on newly sequenced genomes -
locations which can change as higher quality sequencing data becomes
available. Although a LiveSeq object is not implemented in the same way as
a Seq object, LiveSeq does implement the SeqI interface (see below).
Consequently, most methods available for Seq objects will work fine with
LiveSeq objects. Section <emphasis>III.7.2</emphasis>
and <emphasis>Bio</emphasis> contain further discussion of LiveSeq objects.


</para>

<para>
SeqI objects are Seq ``interface objects'' (see section <emphasis>II.4</emphasis> and
<emphasis>Bio</emphasis>). They are used to ensure bioperl's compatibility with other software
packages. SeqI and other interface objects are not likely to be relevant to
the casual bioperl user.


</para>

<para>
*** Having described these other types of sequence objects, the ``bottom
line'' still is that if you store your sequence data in Seq objects (which
is where they'll be if you read them in with SeqIO), you will usually do
just fine. ***


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-4-b"><title>II.2 Alignment objects (SimpleAlign)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Early versions of bioperl used both UnivAln and SimpleAlign objects to
represent and manipulate alignments but as of v. 1.0 only SimpleAlign.pm is
supported. This module allows the user to convert between alignment formats
as well as more sophisticated operations, like extracting specific regions
of the alignment and generating consensus sequences. For more information
see section <emphasis>III.5.4</emphasis> and <emphasis>Bio</emphasis>.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-4-c"><title>II.3 Location objects

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
A Location object is designed to be associated with a Sequence Feature
object to indicate where on a larger structure (eg a chromosome or contig)
the feature can be found. The reason why this simple concept has evolved in
a collection of rather complicated objects is that


</para>

<para>
1) Some objects have multiple locations or sub-locations (eg a gene's exons
may have multiple start and stop locations) 2) In unfinished genomes, the
precise locations of features is not known with certainty.


</para>

<para>
Bioperl's various Location objects address these complications. In addition
there are ``CoordinatePolicy'' objects that allow the user to specify how
to measure the ``length'' of a feature if its precise start and end
coordinates are not know. In most cases, you will not need to worry about
these complications if you are using bioperl to handle simple features with
well-defined start and stop locations. However, if you are using bioperl to
annotate partially or unfinished genomes or to read annotations of such
genomes with bioperl, understanding the various Location objects will be
important. See the documentation of the various modules in the
Bio::Locations directory or
<emphasis>Bio</emphasis> for more information.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-4-d"><title>II.4 Interface objects and implementation objects

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Since release 0.6, bioperl has been moving to separate interface and
implementation objects. An interface is solely the definition of what
methods one can call on an object, without any knowledge of how it is
implemented. An implementation is an actual, working implementation of an
object. In languages like Java, interface definition is part of the
language. In Perl, you have to roll your own.


</para>

<para>
In bioperl, the interface objects usually have names like Bio::MyObjectI,
with the trailing I indicating it is an interface object. The interface
objects mainly provide documentation on what the interface is, and how to
use it, without any implementations (though there are some exceptions).
Although interface objects are not of much direct utility to the casual
bioperl user, being aware of their existence is useful since they are the
basis to understanding how bioperl programs can communicate with other
bioinformatics projects such as Ensembl and the Annotation Workbench (see
section IV).


</para>

<para>
For more discussion of design and development issues please see the
biodesign.pod file.


</para>

</sect2>

</sect1>

<sect1 id="pod2docbook-ch-1-sect-5"><title>III. Using bioperl

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Bioperl provides software modules for many of the typical tasks of
bioinformatics programming. These include:


</para>

<itemizedList>
<listitem><para>
Accessing sequence data from local and remote databases

</para>

</listitem>
<listitem><para>
Transforming formats of database/ file records

</para>

</listitem>
<listitem><para>
Manipulating individual sequences

</para>

</listitem>
<listitem><para>
Searching for "similar" sequences

</para>

</listitem>
<listitem><para>
Creating and manipulating sequence alignments

</para>

</listitem>
<listitem><para>
Searching for genes and other structures on genomic DNA

</para>

</listitem>
<listitem><para>
Developing machine readable sequence annotations

</para>

</listitem></itemizedList>

<para>
The following sections describe how bioperl can help perform all of these
tasks.


</para>

<sect2 id="pod2docbook-ch-1-sect-5-a"><title>III.1 Accessing sequence data from local and remote databases

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Much of bioperl is focused on sequence manipulation. However, before
bioperl can manipulate sequences, it needs to have access to sequence data.
Now one can directly enter data sequence data into a bioperl Seq object,
eg:


</para>

<para>
<screen>
  $seq = Bio::Seq-&gt;new('-seq'=&gt;'actgtggcgtcaact',
                       '-desc'=&gt;'Sample Bio::Seq object',
                       '-display_id' =&gt; 'something',
                       '-accession_number' =&gt; 'accnum',
                       '-alphabet' =&gt; 'dna' );
</screen>


</para>

<para>
However, in most cases, it is preferable to access sequence data from some
online data file or database (Note that in common with conventional
bioinformatics usage we will call a ``database'' what might be more
appropriately referred to as an ``indexed flat file''.) Bioperl supports
accessing remote databases as well as developing indices for setting up
local databases.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-b"><title>III.1.1 Accessing remote databases (Bio::DB::GenBank, etc)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Accessing sequence data from the principal molecular biology databases is
straightforward in bioperl. Data can be accessed by means of the sequence's
accession number or id. Batch mode access is also supported to facilitate
the efficient retrieval of multiple sequences. For retrieving data from
genbank, for example, the code could be as follows:


</para>

<para>
<screen>
  $gb = new Bio::DB::GenBank();
  # this returns a Seq object :
  $seq1 = $gb-&gt;get_Seq_by_id('MUSIGHBA1');
  # this returns a Seq object :
  $seq2 = $gb-&gt;get_Seq_by_acc('AF303112'))
  # this returns a SeqIO object :
  $seqio = $gb-&gt;get_Stream_by_batch([ qw(J00522 AF303112 2981014)]));
</screen>


</para>

<para>
Bioperl currently supports sequence data retrieval from the genbank,
genpept, RefSeq, swissprot, and EMBL databases. See <emphasis>Bio</emphasis>,
<emphasis>Bio</emphasis>, <emphasis>Bio</emphasis>, <emphasis>Bio</emphasis> and
<emphasis>Bio</emphasis> for more information. A user can also specify a different database mirror
for a database - this is especially relevent for the SwissProt resource
where there are many ExPaSy mirrors. There are also configuration options
for specifying local proxy servers for those behind firewalls.


</para>

<para>
The retrieval of NCBI RefSeqs sequences is supported through a special
module called Bio::DB::RefSeq which actually queries an EBI server. Please
see <emphasis>Bio</emphasis> before using it as there are some caveats with RefSeq retrieval. RefSeq ids
in Genbank begin with ``NT_'', ``NC_'', ``NG_'', ``NM_'', ``NP_'', ``XM_'',
``XR_'', or ``XP_'' (for more information see
http://www.ncbi.nlm.nih.gov/LocusLink/refseq.html). Bio::DB::GenBank can be
used to retrieve entries corresponding to these ids but bear in mind that
these are not Genbank entries, strictly speaking. See
<emphasis>Bio</emphasis> for special details on retrieving entries beginning with ``NT_'', these are
specially formatted ``CONTIG'' entries.


</para>

<para>
Bioperl also supports retrieval from a remote Ace database. This capability
requires the presence of the external AcePerl module. You need to download
and install the aceperl module from http://stein.cshl.org/AcePerl/.


</para>

<para>
An additional module is available for accessing remote databases, BioFetch,
which queries the dbfetch script at EBI. The available databases are EMBL,
GenBank, or SWALL, and the entries can be retrieved in different formats as
objects or streams (SeqIO objects), or as ``tempfiles''. See
<emphasis>Bio</emphasis> for the details.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-c"><title>III.1.2 Indexing and accessing local databases (Bio::Index::*, bpindex.pl, bpfetch.pl, Bio::DB::*)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Alternately, bioperl permits indexing local sequence data files by means of
the Bio::Index or Bio::DB::Fasta objects. The following sequence data
formats are supported by Bio::Index: genbank, swissprot, pfam, embl and
fasta. Once the set of sequences have been indexed using Bio::Index,
individual sequences can be accessed using syntax very similar to that
described above for accessing remote databases. For example, if one wants
to set up an indexed (flat-file) database of fasta files, and later wants
then to retrieve one file, one could write a scripts like:


</para>

<para>
<screen>
  # script 1: create the index
  use Bio::Index::Fasta; # using fasta file format
  $Index_File_Name = shift;
  $inx = Bio::Index::Fasta-&gt;new(
      -filename =&gt; $Index_File_Name,
      -write_flag =&gt; 1);
  $inx-&gt;make_index(@ARGV);
</screen>


</para>

<para>
<screen>
  # script 2: retrieve some files
  use Bio::Index::Fasta;
  $Index_File_Name = shift;
  $inx = Bio::Index::Fasta-&gt;new($Index_File_Name);
  foreach  $id (@ARGV) {
      $seq = $inx-&gt;fetch($id);  # Returns Bio::Seq object
      # do something with the sequence
  }
</screen>


</para>

<para>
To facilitate the creation and use of more complex or flexible indexing
systems, the bioperl distribution includes two sample scripts in the
scripts/ directory, bpindex.pl and bpfetch.pl. These scripts can be used as
templates to develop customized local data-file indexing systems.


</para>

<para>
Bioperl also supplies Bio::DB::Fasta as a means to index and query Fasta
format files. It's similar in spirit to Bio::Index::Fasta but offers more
methods, eg


</para>

<para>
<screen>
  use Bio::DB::Fasta;
  $db = Bio::DB::Fasta-&gt;new($file);  # one file or many files
  $seqstring = $db-&gt;seq($id);        # get a sequence as string
  $seqobj = $db-&gt;get_Seq_by_id($id); # get a PrimarySeq obj
  $desc = $db-&gt;header($id);          # get the header, or description, line
</screen>


</para>

<para>
This module also offers the user the ability to designate a specific string
within the fasta header as the desired id, such as the gi number within the
string ``gi|4556644|gb|X45555'' (use the -makeid option for this
capability). See <emphasis>Bio</emphasis> for more information on this fully-featured module.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-d"><title>III.2 Transforming formats of database/ file records

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-e"><title>III.2.1 Transforming sequence files (SeqIO)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
A common - and tedious - bioinformatics task is that of converting sequence
data among the many widely used data formats. Bioperl's SeqIO object,
however, makes this chore a breeze. SeqIO can read a stream of sequences -
located in a single or in multiple files - in a number of formats: Fasta,
EMBL, GenBank, Swissprot, PIR, GCG, SCF, phd/phred, Ace, or raw (plain
sequence). Once the sequence data has been read in with SeqIO, it is
available to bioperl in the form of Seq objects. Moreover, the Seq objects
can then be written to another file (again using SeqIO) in any of the
supported data formats making data converters simple to implement, for
example:


</para>

<para>
<screen>
  use Bio::SeqIO;
  $in  = Bio::SeqIO-&gt;new('-file' =&gt; "inputfilename",
                         '-format' =&gt; 'Fasta');
  $out = Bio::SeqIO-&gt;new('-file' =&gt; "&gt;outputfilename",
                         '-format' =&gt; 'EMBL');
  while ( my $seq = $in-&gt;next_seq() ) {$out-&gt;write_seq($seq); }
</screen>


</para>

<para>
In addition, perl ``tied filehandle'' syntax is available to SeqIO,
allowing you to use the standard &lt;&gt; and print operations to read and write sequence objects, eg:


</para>

<para>
<screen>
  $in  = Bio::SeqIO-&gt;newFh('-file' =&gt; "inputfilename" ,
                           '-format' =&gt; 'Fasta');
  $out = Bio::SeqIO-&gt;newFh('-format' =&gt; 'EMBL');
  print $out $_ while &lt;$in&gt;;
</screen>


</para>

<para>
If the ``-format'' argument isn't used then Bioperl will guess the format
based on the file's suffix in a case-insensitive manner. Here are the
current interpretations:


</para>

<para>
<screen>
   Format   Suffixes
</screen>


</para>

<para>
<screen>
   fasta    fasta|fast|seq|fa|fsa|nt|aa
   genbank  gb|gbank|genbank
   scf      scf
   pir      pir
   embl     embl|ebl|emb|dat
   raw      txt
   gcg      gcg
   ace      ace
   bsml     bsm|bsml
   swiss    swiss|sp
   phd      phd|phred
</screen>


</para>

<para>
For more information see <emphasis>Bio</emphasis>.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-f"><title>III.2.2 Transforming alignment files (AlignIO)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Data files storing multiple sequence alignments also appear in varied
formats. AlignIO is the bioperl object for data conversion of alignment
files. AlignIO is patterned on the SeqIO object and shares most of SeqIO's
features. AlignIO currently supports input in the following formats: fasta,
mase, stockholm, prodom, selex, bl2seq, clustalw, msf/gcg, water (from
EMBOSS, see <emphasis>III.3.6</emphasis>), needle (from EMBOSS, see
<emphasis>III.3.6</emphasis>) and output in these formats: fasta, mase, selex, clustalw, msf/gcg. One
significant difference between AlignIO and SeqIO is that AlignIO handles IO
for only a single alignment at a time (SeqIO.pm handles IO for multiple
sequences in a single stream.) Syntax for AlignIO is almost identical to
that of SeqIO:


</para>

<para>
<screen>
  use Bio::AlignIO;
  $in  = Bio::AlignIO-&gt;new('-file' =&gt; "inputfilename" ,
                           '-format' =&gt; 'fasta');
  $out = Bio::AlignIO-&gt;new('-file' =&gt; "&gt;outputfilename",
                           '-format' =&gt; 'pfam');
  while ( my $aln = $in-&gt;next_aln() ) { $out-&gt;write_aln($aln); }
</screen>


</para>

<para>
The only difference is that here, the returned object reference, $aln, is
to a SimpleAlign object rather than a Seq object.


</para>

<para>
AlignIO also supports the tied filehandle syntax described above for SeqIO.
Note that currently AlignIO is usable only with SimpleAlign alignment
objects. See <emphasis>Bio</emphasis> and section <emphasis>III.5.4</emphasis> for more information.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-g"><title>III.3 Manipulating sequences

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Bioperl contains many modules with functions for sequence analysis. And if
you cannot find the function you want in bioperl you may be able to find it
in EMBOSS, which is accessible through bioperl (see <emphasis>III.3.6</emphasis>).


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-h"><title>III.3.1  Manipulating sequence data with Seq methods

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
OK, so we know how to retrieve sequences and access them as Seq objects.
Let's see how we can use the Seq objects to manipulate our sequence data
and retrieve information. Seq provides multiple methods for performing many
common (and some not-so-common) tasks of sequence manipulation and data
retrieval. Here are some of the most useful:


</para>

<para>
The following methods return strings


</para>

<para>
<screen>
  $seqobj-&gt;display_id(); # the human read-able id of the sequence
  $seqobj-&gt;seq();        # string of sequence
  $seqobj-&gt;subseq(5,10); # part of the sequence as a string
  $seqobj-&gt;accession_number(); # when there, the accession number
  $seqobj-&gt;alphabet();   # one of 'dna','rna','protein'
  $seqobj-&gt;primary_id(); # a unique id for this sequence irregardless
                         # of its display_id or accession number
  $seqobj-&gt;desc()        # a description of the sequence
</screen>


</para>

<para>
It is worth mentioning that some of these values correspond to specific
fields of given formats. For example, the display_id method returns the
LOCUS name of a Genbank entry, the (\S+) following the &gt; character in a Fasta file, the ID from a SwissProt file, and so on. The
<literal>desc()</literal> method will return the DEFINITION line of a
Genbank file, the line following the display_id in a Fasta file, and the DE
field in a SwissProt file.


</para>

<para>
The following methods return an array of Bio::SeqFeature objects


</para>

<para>
<screen>
   $seqobj-&gt;top_SeqFeatures # The 'top level' sequence features
   $seqobj-&gt;all_SeqFeatures # All sequence features, including sub
                            # seq features
</screen>


</para>

<para>
Sequence features will be discussed further in section <emphasis>III.7</emphasis> on machine-readable sequence annotation. A general description of the
object can be found in <emphasis>Bio</emphasis>, and a description of related, top-level ``annotation'' is found in <emphasis>Bio</emphasis>.


</para>

<para>
The following methods returns new sequence objects, but do not transfer
features across:


</para>

<para>
<screen>
  $seqobj-&gt;trunc(5,10)  # truncation from 5 to 10 as new object
  $seqobj-&gt;revcom       # reverse complements sequence
  $seqobj-&gt;translate    # translation of the sequence
</screen>


</para>

<para>
Note that some methods return strings, some return arrays and some return
references to objects. See <emphasis>Bio</emphasis> for more information.


</para>

<para>
Many of these methods are self-explanatory. However, bioperl's flexible
translation methods warrant further comment. Translation in bioinformatics
can mean two slightly different things:


</para>

<orderedList>
<listitem>
<para>
 Translating a nucleotide sequence from start to end.

</para>

</listitem>
<listitem>
<para>
 Taking into account the constraints of real coding regions in mRNAs.

</para>

</listitem></orderedlist>

<para>
For historical reasons the bioperl implementation of translation does the
first of these tasks easily. Any sequence object which is not of type
'protein' can be translated by simply calling the method which returns a
protein sequence object:


</para>

<para>
<screen>
  $translation1 = $my_seq_object-&gt;translate;
</screen>


</para>

<para>
However, the translate method can also be passed several optional
parameters to modify its behavior. For example, the first two arguments to
``translate'' can be used to modify the characters used to represent stop
(default '*') and unknown amino acid ('X'). (These are normally best left
untouched.) The third argument determines the frame of the translation. The
default frame is ``0''. To get translations in the other two forward
frames, we would write:


</para>

<para>
<screen>
  $translation2 = $my_seq_object-&gt;translate(undef,undef,1);
  $translation3 = $my_seq_object-&gt;translate(undef,undef,2);
</screen>


</para>

<para>
The fourth argument to ``translate'' makes it possible to use alternative
genetic codes. There are currently 16 codon tables defined, including
tables for 'Verterbate Mitochondrial', 'Bacterial', 'Alternative Yeast
Nuclear' and 'Ciliate, Dasycladacean and Hexamita Nuclear' translation.
These tables are located in the object Bio::Tools::CodonTable which is used
by the translate method. For example, for mitochondrial translation:


</para>

<para>
<screen>
  $human_mitochondrial_translation =
      $my_seq_object-&gt;translate(undef,undef,undef, 2);
</screen>


</para>

<para>
If we want to translate full coding regions (CDS) the way major nucleotide
databanks EMBL, GenBank and DDBJ do it, the translate method has to perform
more tricks. Specifically, 'translate' needs to confirm that the sequence
has appropriate start and terminator codons at the beginning and the end of
the sequence and that there are no terminator codons present within the
sequence. In addition, if the genetic code being used has an atypical
(non-ATG) start codon, the translate method needs to convert the initial
amino acid to methionine. These checks and conversions are triggered by
setting the fifth argument of the translate method to evaluate to ``true''.


</para>

<para>
If argument 5 is set to true and the criteria for a proper CDS are not met,
the method, by default, issues a warning. By setting the sixth argument to
evaluate to ``true'', one can instead instruct the program to die if an
improper CDS is found, e.g.


</para>

<para>
<screen>
  $protein_object =
      $cds-&gt;translate(undef,undef,undef,undef,1,'die_if_errors');
</screen>


</para>

<para>
See <emphasis>Bio</emphasis> for related details.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-i"><title>III.3.2 Obtaining basic
sequence statistics- MW, residue &amp; codon
frequencies(SeqStats, SeqWord)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
In addition to the methods directly available in the Seq object, bioperl
provides various ``helper'' objects to determine additional information
about a sequence. For example, SeqStats object provides methods for
obtaining the molecular weight of the sequence as well the number of
occurrences of each of the component residues (bases for a nucleic acid or
amino acids for a protein.) For nucleic acids, SeqStats also returns counts
of the number of codons used. For example:


</para>

<para>
<screen>
  use SeqStats;
  $seq_stats  =  Bio::Tools::SeqStats-&gt;new($seqobj);
  $weight = $seq_stats-&gt;get_mol_wt();
  $monomer_ref = $seq_stats-&gt;count_monomers();
  $codon_ref = $seq_stats-&gt;count_codons();  # for nucleic acid sequence
</screen>


</para>

<para>
Note: sometimes sequences will contain ``ambiguous'' codes. For this
reason, <literal>get_mol_wt()</literal> returns (a reference to) a two
element array containing a greatest lower bound and a least upper bound of
the molecular weight.


</para>

<para>
The SeqWords object is similar to SeqStats and provides methods for
calculating frequencies of ``words'' (eg tetramers or hexamers) within the
sequence. See <emphasis>Bio</emphasis> and <emphasis>Bio</emphasis>
for more information.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-j"><title>III.3.3 Identifying restriction enzyme sites (RestrictionEnzyme)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Another common sequence manipulation task for nucleic acid sequences is
locating restriction enzyme cutting sites. Bioperl provides the
RestrictionEnzyme object for this purpose. Bioperl's standard
RestrictionEnzyme object comes with data for more than 150 different
restriction enzymes. A list of the available enzymes can be accessed using
the <literal>available_list()</literal> method. For example to select all
available enzymes that with cutting patterns that are six bases long one
would write:


</para>

<para>
<screen>
  $re  = new Bio::Tools::RestrictionEnzyme('-name'=&gt;'EcoRI');
  @sixcutters = $re-&gt;available_list(6);
</screen>


</para>

<para>
Once an appropriate enzyme has been selected, the sites for that enzyme on
a given nucleic acid sequence can be obtained using the
<literal>cut_seq()</literal> method. The syntax for performing this task
is:


</para>

<para>
<screen>
  $re1 = new Bio::Tools::RestrictionEnzyme(-name=&gt;'EcoRI');
  # $seqobj is the Seq object for the dna to be cut
  @fragments =  $re1-&gt;cut_seq($seqobj);
</screen>


</para>

<para>
Adding an enzyme not in the default list is easily accomplished:


</para>

<para>
<screen>
  $re2 = new Bio::Tools::RestrictionEnzyme('-NAME' =&gt;'EcoRV--GAT^ATC',
                                           '-MAKE' =&gt;'custom');
</screen>


</para>

<para>
Once the custom enzyme object has been created,
<literal>cut_seq()</literal> can be called in the usual manner. See <emphasis>Bio</emphasis> for details.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-k"><title>III.3.4 Identifying amino acid cleavage sites (Sigcleave)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
For amino acid sequences we may be interested to know whether the amino
acid sequence contains a cleavable ``signal sequence'' for directing the
transport of the protein within the cell. SigCleave is a program
(originally part of the EGCG molecular biology package) to predict signal
sequences, and to identify the cleavage site.


</para>

<para>
The ``threshold'' setting controls the score reporting. If no value for
threshold is passed in by the user, the code defaults to a reporting value
of 3.5. SigCleave will only return score/position pairs which meet the
threshold limit.


</para>

<para>
There are 2 accessor methods for this object. ``signals'' will return a
perl hash containing the sigcleave scores keyed by amino acid position.
``pretty_print'' returns a formatted string similar to the output of the
original sigcleave utility.


</para>

<para>
Syntax for using the modules is as follows:


</para>

<para>
<screen>
  use Bio::Tools::Sigcleave;
  $sigcleave_object = new Bio::Tools::Sigcleave
      ('-file'=&gt;'sigtest.aa',
       '-threshold'=&gt;'3.5'
       '-desc'=&gt;'test sigcleave protein seq',
       '-type'=&gt;'AMINO
      ');
  %raw_results      = $sigcleave_object-&gt;signals;
  $formatted_output = $sigcleave_object-&gt;pretty_print;
</screen>


</para>

<para>
Note that Sigcleave is passed a raw sequence (or file containing a
sequence) rather than a sequence object when it is created. Also note that
the ``type'' in the Sigcleave object is ``amino'' whereas in a Seq object
it is ``protein''. Please see <emphasis>Bio</emphasis> for details.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-l"><title>III.3.5 Miscellaneous sequence utilities: OddCodes, SeqPattern

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
OddCodes:


</para>

<para>
For some purposes it's useful to have a listing of an amino acid sequence
showing where the hydrophobic amino acids are located or where the
positively charged ones are. Bioperl provides this capability via the
module Bio::Tools::OddCodes.


</para>

<para>
For example, to quickly see where the charged amino acids are located along
the sequence we perform:


</para>

<para>
<screen>
  use Bio::Tools::OddCodes;
  $oddcode_obj = Bio::Tools::OddCodes-&gt;new($amino_obj);
  $output = $oddcode_obj-&gt;charge();
</screen>


</para>

<para>
The sequence will be transformed into a three-letter sequence (A,C,N) for
negative (acidic), positive (basic), and neutral amino acids. For example
the ACDEFGH would become NNAANNC.


</para>

<para>
For a more complete chemical description of the sequence one can call the
<literal>chemical()</literal> method which turns sequence into one with an
8-letter chemical alphabet { A (acidic), L (aliphatic), M (amide), R
(aromatic), C (basic), H (hydroxyl), I (imino), S (sulfur) }:


</para>

<para>
<screen>
  $output = $oddcode_obj-&gt;chemical();
</screen>


</para>

<para>
In this case the sample sequence ACDEFGH would become LSAARAC.


</para>

<para>
OddCodes also offers translation into alphabets showing alternate
characteristics of the amino acid sequence such as hydrophobicity,
``functionality'' or grouping using Dayhoff's definitions. See the
documentation in <emphasis>Bio</emphasis> for further details.


</para>

<para>
SeqPattern:


</para>

<para>
The SeqPattern object is used to manipulate sequences that include perl
``regular expressions''. A key motivation for SeqPattern is to have a way
of generating a reverse complement of a nucleic acid sequence pattern that
includes ambiguous bases and/or regular expressions. This capability leads
to significant performance gains when pattern matching on both the sense
and anti-sense strands of a query sequence are required. Typical syntax for
using SeqPattern is shown below. For more information, there are several
interesting examples in the script seq_pattern.pl in the examples/
directory.


</para>

<para>
<screen>
  Use Bio::Tools::SeqPattern;
  $pattern     = '(CCCCT)N{1,200}(agggg)N{1,200}(agggg)';
  $pattern_obj = new Bio::Tools::SeqPattern('-SEQ'  =&gt; $pattern,
                                            '-TYPE' =&gt; 'dna');
  $pattern_obj2  = $pattern_obj-&gt;revcom();
  $pattern_obj-&gt;revcom(1); # returns expanded rev complement pattern.
</screen>


</para>

<para>
More detail can be found in <emphasis>Bio</emphasis>.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-m"><title>III.3.6 Sequence manipulation using the Bioperl EMBOSS interface (Tools::Run::EMBOSSApplication)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
EMBOSS (European Molecular Biology Open Source Software) is an extensive
collection of sequence analysis programs written in the C programming
language, from http://www.uk.embnet.org/Software/EMBOSS. There are a number
of algorithms in EMBOSS that are not found in ``Bioperl proper'' (eg.
calculating DNA melting temperature, finding repeats, identifying
prospective antigenic sites) so if you if you cannot find the function you
want in bioperl you might be able to find it in EMBOSS.


</para>

<para>
EMBOSS programs are usually called from the command line but bioperl
provides a Perl ``wrapper'' for EMBOSS function calls so that they can be
executed from within a Perl script. Of course, the EMBOSS package must be
installed for the Bioperl wrapper to function.


</para>

<para>
In the future, it is planned that Bioperl EMBOSS objects will return
appropriate Bioperl objects to the calling script in addition to generating
standard EMBOSS reports. This functionality is being initially implemented
with the EMBOSS sequence alignment programs, so that they will return
SimpleAlign objects in a manner similar to the way the Bioperl modules
TCoffee.pm and Clustalw.pm work (see section <emphasis>III.5.4</emphasis> for a discussion of SimpleAlign).


</para>

<para>
An example of the Bioperl EMBOSS wrapper where a file is returned would be:


</para>

<para>
<screen>
  $factory = new Bio::Factory::EMBOSS;
  $compseqapp = $factory-&gt;program('compseq');
  %input = ( -word     =&gt; 4,
             -sequence =&gt; $seqObj,
             -outfile  =&gt; $compseqoutfile );
  $compseqapp-&gt;run(\%input);
  $seqio = Bio::SeqIO-&gt;new( -file =&gt; $compseqoutfile ); # etc...
</screen>


</para>

<para>
Note that a Seq object was used as input. The EMBOSS object can also accept
a file name as input, eg


</para>

<para>
<screen>
  -sequence =&gt; "inputfasta.fa"
</screen>


</para>

<para>
Some EMBOSS programs will return strings, others will create files that can
be read directly using Bio::SeqIO (section <emphasis>III.2.1</emphasis>), as in the example above. It's worth mentioning that the AlignIO module
can use files from EMBOSS's water and needle as input (see <emphasis>III.2.2</emphasis>) to create AlignIO objects.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-n"><title>III.3.7 Sequence manipulation without creating Bioperl "objects" (Perl.pm)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Using the Bio::Perl.pm module, it is possible to manipulate sequence data
in Bioperl without explicitly creating Seq or SeqIO objects. This feature
may ease the Bioperl learning curve for new users unfamiliar or
uncomfortable with using Perl objects. However, only limited data
manipulation are supported in this mode. In addition, each method (i.e.
function) that will be used by the script must be explicitly declared in
the initial ``use directive''. For example a simple data format conversion
and sequence manipulation could be performed as follows - note that no
``new'' methods are called and that no Seq or SeqIO objects are created:


</para>

<para>
<screen>
  use Bio::Perl qw( get_sequence );
  # get a sequence from a database (assummes internet connection)
  $seq_object = get_sequence('swissprot',"ROA1_HUMAN");
  # $seq_object is Bio::Seq object, so the following methods work
  $seq_id  = $seq_object-&gt;display_id;
  $seq_as_string = $seq_object-&gt;seq();
</screen>


</para>

<para>
For more details see <emphasis>Bio</emphasis>




</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-o"><title>III.4 Searching for "similar" sequences

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
One of the basic tasks in molecular biology is identifying sequences that
are, in some way, similar to a sequence of interest. The Blast programs,
originally developed at the NCBI, are widely used for identifying such
sequences. Bioperl offers a number of modules to facilitate running Blast
as well as to parse the often voluminous reports produced by Blast.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-p"><title>III.4.1 Running BLAST locally  (StandAloneBlast)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
There are several reasons why one might want to run the Blast programs
locally - speed, data security, immunity to network problems, being able to
run large batch runs etc. The NCBI provides a downloadable version of blast
in a stand-alone format, and running blast locally without any use of perl
or bioperl is completely straightforward. However, there are situations
where having a perl interface for running the blast programs locally is
convenient.


</para>

<para>
The module Bio::Tools::Run::StandAloneBlast offers the ability to wrap
local calls to blast from within perl. All of the currently available
options of NCBI Blast (eg PSIBLAST, PHIBLAST, bl2seq) are available from
within the bioperl StandAloneBlast interface. Of course, to use
StandAloneBlast, one needs to have installed locally ncbi-blast as well as
one or more blast-readable databases.


</para>

<para>
Basic usage of the StandAloneBlast.pm module is simple. Initially, a local
blast ``factory object'' is created.


</para>

<para>
<screen>
  @params = ('program'  =&gt; 'blastn',
             'database' =&gt; 'ecoli.nt');
  $factory = Bio::Tools::Run::StandAloneBlast-&gt;new(@params);
</screen>


</para>

<para>
Any parameters not explicitly set will remain as the BLAST defaults. Once
the factory has been created and the appropriate parameters set, one can
call one of the supported blast executables. The input
<literal>sequence(s)</literal> to these executables may be fasta
<literal>file(s),</literal> a Seq object or an array of Seq objects, eg


</para>

<para>
<screen>
  $input = Bio::Seq-&gt;new('-id'=&gt;"test query",
                         '-seq'=&gt;"ACTAAGTGGGGG");
  $blast_report = $factory-&gt;blastall($input);
</screen>


</para>

<para>
The returned blast report will be in the form of a bioperl parsed-blast
object. The report object may be either a BPlite, BPpsilite, BPbl2seq or
Blast object depending on the type of blast search. The ``raw'' blast
report is also available.


</para>

<para>
The syntax for running PHIBLAST, PSIBLAST and bl2seq searches via
StandAloneBlast is also straightforward. See
<emphasis>Bio</emphasis> documentation for details. In addition, the script standaloneblast.pl in
the examples/ directory contains descriptions of various possible
applications of the StandAloneBlast object. This script shows how the blast
report object can access a blast parser directly, eg


</para>

<para>
<screen>
  while (my $sbjct = $blast_report-&gt;nextSbjct){
     while (my $hsp = $sbjct-&gt;nextHSP){
        print $hsp-&gt;score . " " . $hsp-&gt;subject-&gt;seqname . "\n";
     }
  }
</screen>


</para>

<para>
See the section <emphasis>III.4.4</emphasis> on parsing BLAST reports with Bio::Tools::BPlite, below, or <emphasis>Bio</emphasis> for details.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-q"><title>III.4.2 Running BLAST remotely (using RemoteBlast.pm)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Bioperl supports remote execution of blasts at NCBI by means of the
RemoteBlast object. (Note: remote execution of blasts is also possible
using the bioperl Bio::Tools::Blast object. However this Blast object is no
longer supported and its interface - especially for running Blasts is
somewhat complicated. Consequently, the user is advised to use the
Bio::Tools::Run::RemoteBlast object for this purpose - unless you really
know what you're doing!)


</para>

<para>
A skeleton script to run a remote blast might look as follows:


</para>

<para>
<screen>
  $remote_blast = Bio::Tools::Run::RemoteBlast-&gt;new(
           '-prog' =&gt; 'blastp','-data' =&gt; 'ecoli','-expect' =&gt; '1e-10' );
  $r = $remote_blast-&gt;submit_blast("t/data/ecolitst.fa");
  while (@rids = $remote_blast-&gt;each_rid ) {
      foreach $rid ( @rids ) {$rc = $remote_blast-&gt;retrieve_blast($rid);}}
</screen>


</para>

<para>
Note that the script has to be broken into two parts. The actual Blast
submission and the subsequent retrieval of the results. At times when the
NCBI Blast is being heavily used, the interval between when a Blast
submission is made and when the results are available can be substantial.


</para>

<para>
The object <literal>$rc</literal> would contain the blast report that could
then be parsed with Bio::Tools::BPlite or Bio::Tools::Blast. Note that to
make this script actually useful, one should add details such as checking
return codes from the Blast to see if it succeeded and and a ``sleep'' loop
to wait between consecutive requests to the NCBI server. See example 21 in
the demonstration script in the appendix to see some working code you could
use, or
<emphasis>Bio</emphasis> for details.


</para>

<para>
It should also be noted that the syntax for creating a remote blast factory
is slightly different from that used in creating StandAloneBlast, Clustalw,
and T-Coffee factories. Specifically RemoteBlast requires parameters to be
passed with a leading hyphen, as in '-prog' =&gt; 'blastp', while the other programs do not pass parameters with a leading
hyphen.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-r"><title>III.4.3 Parsing BLAST and FASTA reports with Search and SearchIO

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
No matter how Blast searches are run (locally or remotely, with or without
a perl interface), they return large quantities of data that are tedious to
sift through. Bioperl offers several different objects - Search.pm /
SearchIO.pm, BPlite.pm (along with its minor modifications, BPpsilite and
BPbl2seq) and Blast.pm for parsing Blast reports. Search and SearchIO which
are new in Bioperl 1.0 and are now the principal Bioperl interfaces for
Blast (and FASTA) report parsing are described in this section. The older
BPlite and Blast.pm objects are described in section <emphasis>III.4.4</emphasis>.


</para>

<para>
The Search and SearchIO modules provide a uniform interface for parsing
sequence-similarity-search reports generated by BLAST (in standard and
BLAST XML formats), PSIBLAST and FASTA. In the future, it is envisioned
that the Search/SearchIO syntax will be extended to provide a uniform
interface to a wider range of report parsers including parsers for HMMer
and Genscan.


</para>

<para>
Parsing sequence-similarity reports with Search and SearchIO is
straightforward. Initially a SearchIO object specifies a file containing
the <literal>report(s).</literal> The method next_result reads the next
report into a Search object in just the same way that the next_seq method
of SeqIO reads in the next sequence in a file into a Seq object.


</para>

<para>
Once a report (i.e. a Search object) has been read in and is available to
the script, the report's overall attributes (e.g. the query) can be
determined and its individual ``hits'' can be accessed with the next_hit
method. Individual high-scoring-pairs for each hit can then be accessed
with the next_hsp method. Except for the additional syntax required to
enable the reading of multiple reports in a single file, the remainder of
the Search/SearchIO parsing syntax is very similar to that of the BPlite
and Blast.pm objects it is intended to replace. Sample code to read a BLAST
report might look like this:


</para>

<para>
<screen>
  # Get the report
  $searchio = new Bio::SearchIO ('-format' =&gt; 'blast',
                                 '-file'   =&gt; $blast_report);
  $result = $searchio-&gt;next_result;
</screen>


</para>

<para>
<screen>
  # Get info about the entire report
  $result-&gt;database_name;
  $algorithm_type =  $result-&gt;algorithm;
</screen>


</para>

<para>
<screen>
  # get info about the first hit
  $hit = $result-&gt;next_hit;
  $hit_name = $hit-&gt;name ;
</screen>


</para>

<para>
<screen>
  # get info about the first hsp of the first hit
  $hsp = $hit-&gt;next_hsp;
  $hsp_start = $hsp-&gt;query-&gt;start;
</screen>


</para>

<para>
For more details on parsing with Search/SearchIO see the next section on
BPlite and Blast.pm (which uses very similar syntax) as well as the Search
and SearchIO documentation: <emphasis>Bio</emphasis>,
<emphasis>Bio</emphasis>, <emphasis>Bio</emphasis>,
<emphasis>Bio</emphasis>, and <emphasis>Bio</emphasis>.


</para>

<para>
There is also sample code is the searchio subdirectory of the Bio/examples
directory which illustrates the use of the Search parser.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-s"><title>III.4.4 Parsing BLAST reports with BPlite, BPpsilite, BPbl2seq and Blast.pm

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Bioperl's older BLAST report parsers - BPlite, BPpsilite, BPbl2seq and
Blast.pm - are expected to be phased out over a period of time. Since a
considerable amount of legacy Bioperl scripts has been written which
heavily use these objects, they are likely to remain within Bioperl for
some time.


</para>

<para>
Much of the user interface of BPlite (and to a lesser degree Blast.pm) is
very similar to that of Search. However accessing the next hit or HSP uses
methods called next_Sbjct and next_HSP, respectively - in contrast to
Search's next_hit and next_hsp.


</para>

<para>
BPlite (with its relatives BPpsilite and BPbl2seq) is less complex and
easier to maintain than Blast.pm. Although it has fewer options and display
modes than Blast.pm, you will probably find that BPlite contains the
functionality that you need, (unless you need to do HSP tiling or to
implement an arbitrary filter function in which case you may want to use
the Blast.pm parser.)


</para>

<para>
BPlite


</para>

<para>
The syntax for using BPlite is as follows where the method for retrieving
hits is now called ``nextSbjct'' (for ``subject''), while the method for
retrieving high-scoring-pairs is called ``nextHSP'':


</para>

<para>
<screen>
  use Bio::Tools::BPlite;
  $report = new Bio::Tools::BPlite(-fh=&gt;\*STDIN);
  $report-&gt;query;
  while(my $sbjct = $report-&gt;nextSbjct) {
       $sbjct-&gt;name;
       while (my $hsp = $sbjct-&gt;nextHSP) { $hsp-&gt;score; }
  }
</screen>


</para>

<para>
A complete description of the module can be found in <emphasis>Bio</emphasis>.


</para>

<para>
BPpsilite


</para>

<para>
BPpsilite and BPbl2seq are objects for parsing (multiple iteration)
PSIBLAST reports and Blast bl2seq reports, respectively. They are both
minor variations on the BPlite object. See <emphasis>Bio</emphasis>
and <emphasis>Bio</emphasis> for details.


</para>

<para>
The syntax for parsing a multiple iteration PSIBLAST report is as shown
below. The only significant additions to BPlite are methods to determine
the number of iterated blasts and to access the results from each
iteration. The results from each iteration are parsed in the same manner as
a (complete) BPlite object.


</para>

<para>
<screen>
  use Bio::Tools::BPpsilite;
  $report = new Bio::Tools::BPpsilite(-fh=&gt;\*STDIN);
  $total_iterations = $report-&gt;number_of_iterations;
  $last_iteration = $report-&gt;round($total_iterations)
  while(my $sbjct =  $last_iteration -&gt;nextSbjct) {
       $sbjct-&gt;name;
       while (my $hsp = $sbjct-&gt;nextHSP) {$hsp-&gt;score; }
  }
</screen>


</para>

<para>
See <emphasis>Bio</emphasis> for details.


</para>

<para>
BPbl2seq


</para>

<para>
BLAST bl2seq is a program for comparing and aligning two sequences using
BLAST. Although the report format is similar to that of a conventional
BLAST, there are a few differences. Consequently, the standard bioperl
parsers Blast.pm and BPlite are unable to read bl2seq reports directly.
From the user's perspective, one difference between bl2seq and other blast
reports is that the bl2seq report does not print out the name of the first
of the two aligned sequences. Consequently, BPbl2seq has no way of
identifying the name of one of the initial sequence unless it is explicitly
passed to constructor as a second argument as in:


</para>

<para>
<screen>
  use Bio::Tools::BPbl2seq;
  $report = Bio::Tools::BPbl2seq-&gt;new(-file =&gt; "t/data/dblseq.out",
                                      -queryname =&gt; "ALEU_HORVU");
  $hsp = $report-&gt;next_feature;
  $answer=$hsp-&gt;score;
</screen>


</para>

<para>
In addition, since there will only be (at most) one ``subject'' (hit) in a
bl2seq report one should use the method $report-&gt;next_feature, rather than $report-&gt;nextSbjct-&gt;nextHSP to obtain the next high scoring pair. See <emphasis>Bio</emphasis> for more details.


</para>

<para>
Blast.pm


</para>

<para>
The parser contained within the Bio::Tools::Blast.pm module is the original
Blast parser developed for Bioperl. It is very full featured and has a
large array of options and output formats. Typical syntax for parsing a
blast report with Blast.pm is:


</para>

<para>
<screen>
  use Bio::Tools::Blast;
  $blast = Bio::Tools::Blast-&gt;new(-file           =&gt;'t/data/blast.report',
                                  -signif         =&gt; 1e-5,
                                  -parse          =&gt; 1,
                                  -stats          =&gt; 1,
                                  -check_all_hits =&gt; 1, );
  $blast-&gt;display();
  $num_hits =  $blast-&gt;num_hits;
  @hits  = $blast-&gt;hits;
  $frac1 = $hits[1]-&gt;frac_identical;
  @inds = $hits[1]-&gt;hsp-&gt;seq_inds( 'query', 'iden', 1 );
</screen>


</para>

<para>
Here the method ``hits'' returns an object containing the names of the
sequences which produced a match and the ``hsp'' method returns a ``high
scoring pair'' object containing the actual sequence alignments that each
of the hits produced.


</para>

<para>
A nice feature of the Blast.pm parser is being able to define an arbitrary
``filter function'' for use while parsing the Blast hits. With this
feature, you can filter your results to just save hits with specific
pattern in their id fields (eg ``homo sapiens'') or specific sequence
patterns in a returned high-scoring-pair or just about anything else that
can be found in the blast report record.


</para>

<para>
While the Blast object is parsing the report, each hit is checked by
calling &amp;filter($hit). All hits that generate false return values from
<literal>&amp;filter</literal> are screened out of the Blast object. Note that
the Blast object will normally stop parsing after the first non-significant
hit or the first hit that does not pass the filter function. To force the
Blast object to check all hits, include a `` -check_all_hits =&gt; 1'' parameter. For example, to eliminate all hits with gaps or with less
than 50% conserved residues one could use the following filter function:


</para>

<para>
<screen>
  sub filter { $hit=shift;
  return ($hit-&gt;gaps == 0 and $hit-&gt;frac_conserved &gt; 0.5); }
</screen>


</para>

<para>
and use it like this:


</para>

<para>
<screen>
  $blastObj = Bio::Tools::Blast-&gt;new( '-file'  =&gt; '/tmp/blast.out',
                                      '-parse'     =&gt; 1,
                                      '-check_all_hits' =&gt; 1,
                                      '-filt_func' =&gt; \&amp;filter );
</screen>


</para>

<para>
Another useful feature of Blast.pm is ``HSP tiling''. With HSP tiling, if a
Blast hit has more than one HSP, Blast.pm has the ability to merge
overlapping HSPs into contiguous blocks. This enables one to sum data
across all HSPs without counting data from overlapping regions multiple
times. HSP tiling is performed automatically when invoking methods that
rely on tiled data such as frac_identical and frac_conserved. For more
information on HSP tiling see the documentation in <emphasis>Bio</emphasis>
and <emphasis>Bio</emphasis>.


</para>

<para>
Unfortunately the flexibility of the Blast.pm parser comes at a cost of
complexity. As a result of this complexity and the fact that Blast.pm's
original developer is no longer actively supporting the module, the
Blast.pm parser has been difficult to maintain and has not been upgraded to
handle the output of the newer blast options such as PSIBLAST and BL2SEQ.
Consequently, the BPlite parser (described in the section <emphasis>III.4.4</emphasis>) or the Search/SearchIO parsers (section <emphasis>III.4.3</emphasis>) are recommended for most blast parsing within bioperl.


</para>

<para>
See <emphasis>Bio</emphasis> for more information.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-t"><title>III.4.5 Parsing HMM reports (HMMER::Results)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Blast is not the only sequence-similarity-searching program supported by
bioperl. HMMER is a Hidden Markov Model (HMM) program that (among other
capabilities) enables sequence similarity searching, from
http://hmmer.wustl.edu. Bioperl does not currently provide a perl interface
for running HMMER. However, bioperl does provide a HMMER report parser with
the (perhaps not too descriptive) name of Results.


</para>

<para>
Results can parse reports generated both by the HMMER program hmmsearch -
which searches a sequence database for sequences similar to those generated
by a given HMM - and the program hmmpfam - which searches a HMM database
for HMMs which match domains of a given sequence. For hmmsearch, a series
of HMMER::Set objects are made, one for each sequence. For hmmpfam
searches, only one Set object is made. Sample usage for parsing a hmmsearch
report might be:


</para>

<para>
<screen>
  use Bio::Tools::HMMER::Results;
  $res = new Bio::Tools::HMMER::Results(-file =&gt; 'output.hmm',
                                        -type =&gt; 'hmmsearch' );
  foreach $seq ( $res-&gt;each_Set ) {
      print "Sequence bit score is ", $seq-&gt;bits, "\n";
      foreach $domain ( $seq-&gt;each_Domain ) {
          print " Domain start ", $domain-&gt;start, " end ",
              $domain-&gt;end," score ",$domain-&gt;bits,"\n";
      }
  }
</screen>


</para>

<para>
Additional methods are described in <emphasis>Bio</emphasis>.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-u"><title>III.5 Creating and manipulating sequence alignments

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Once one has identified a set of similar sequences, one often needs to
create an alignment of those sequences. Bioperl offers several perl objects
to facilitate sequence alignment: pSW, Clustalw.pm, TCoffee.pm and the
bl2seq option of StandAloneBlast. All of these objects take as arguments a
reference to an array of (unaligned) Seq objects. All (except bl2seq)
return a reference to a SimpleAlign object. bl2seq can also produce a
SimpleAlign object when it is combined with Bio::AlignIO (see section
below, <emphasis>III.5.2</emphasis>).


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-v"><title>III.5.1 Aligning 2 sequences with Smith-Waterman (pSW)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
The Smith-Waterman (SW) algorithm is the standard method for producing an
optimal alignment of two sequences. Bioperl supports the computation of SW
alignments via the pSW object. The SW algorithm itself is implemented in C
and incorporated into bioperl using an XS extension. This has significant
efficiency advantages but means that pSW will <emphasis>not</emphasis> work unless you have compiled the bioperl-ext package. If you have compiled
the bioperl-ext package, usage is simple, where the method align_and_show
displays the alignment while pairwise_alignment produces a (reference to) a
SimpleAlign object.


</para>

<para>
<screen>
  use Bio::Tools::pSW;
  $factory = new Bio::Tools::pSW( '-matrix' =&gt; 'blosum62.bla',
                                  '-gap' =&gt; 12,
                                  '-ext' =&gt; 2, );
  $factory-&gt;align_and_show($seq1, $seq2, STDOUT);
  $aln = $factory-&gt;pairwise_alignment($seq1, $seq2);
</screen>


</para>

<para>
SW matrix, gap and extension parameters can be adjusted as shown. Bioperl
comes standard with blosum62 and gonnet250 matrices. Others can be added by
the user. For additional information on accessing the SW algorithm via pSW
see the script psw.pl in the examples/ directory and the documentation in <emphasis>Bio</emphasis>.


</para>

<para>
An alterative way to get Smith-Waterman alignments can come from the EMBOSS
program 'water'. This can produce an output file that bioperl can read in
with the AlignIO system


</para>

<para>
<screen>
  use Bio::AlignIO;
  my $in = new Bio::AlignIO(-format =&gt; 'emboss', -file =&gt; 'filename');
  my $aln = $in-&gt;next_aln();
</screen>


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-w"><title>III.5.2 Aligning 2 sequences with Blast using bl2seq and AlignIO

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
As an alternative to Smith-Waterman, two sequences can also be aligned in
Bioperl using the bl2seq option of Blast within the StandAloneBlast object.
To get an alignment - in the form of a SimpleAlign object - using bl2seq,
you need to parse the bl2seq report with the Bio::AlignIO file format
reader as follows:


</para>

<para>
<screen>
  $factory = Bio::Tools::Run::StandAloneBlast-&gt;new('outfile' =&gt; 'bl2seq.out');
  $bl2seq_report = $factory-&gt;bl2seq($seq1, $seq2);
  # Use AlignIO.pm to create a SimpleAlign object from the bl2seq report
  $str = Bio::AlignIO-&gt;new('-file '=&gt;' bl2seq.out',
                           '-format' =&gt; 'bl2seq');
  $aln = $str-&gt;next_aln();
</screen>


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-x"><title>III.5.3 Aligning multiple sequences (Clustalw.pm, TCoffee.pm)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
For aligning multiple sequences (ie two or more), bioperl offers a perl
interface to the bioinformatics-standard clustalw and tcoffee programs.
Clustalw has been a leading program in global multiple sequence alignment
(MSA) for several years. TCoffee is a relatively recent program - derived
from clustalw - which has been shown to produce better results for local
MSA.


</para>

<para>
To use these capabilities, the clustalw and/or tcoffee programs themselves
need to be installed on the host system. In addition, the environmental
variables CLUSTALDIR and TCOFFEEDIR need to be set to the directories
containg the executables. See section <emphasis>I.3</emphasis> and the
<emphasis>Bio</emphasis> and
<emphasis>Bio</emphasis> for information on downloading and installing these programs.


</para>

<para>
From the user's perspective, the bioperl syntax for calling Clustalw.pm or
TCoffee.pm is almost identical. The only differences are the names of the
modules themselves appearing in the initial ``use'' and constructor
statements and the names of the some of the individual program options and
parameters.


</para>

<para>
In either case, initially, a ``factory object'' must be created. The
factory may be passed most of the parameters or switches of the relevant
program. In addition, alignment parameters can be changed and/or examined
after the factory has been created. Any parameters not explicitly set will
remain as the underlying program's defaults. Clustalw.pm/TCoffee.pm output
is returned in the form of a SimpleAlign object. It should be noted that
some Clustalw and TCoffee parameters and features (such as those
corresponding to tree production) have not been implemented yet in the Perl
interface.


</para>

<para>
Once the factory has been created and the appropriate parameters set, one
can call the method <literal>align()</literal> to align a set of unaligned
sequences, or <literal>profile_align()</literal> to add one or more
sequences or a second alignment to an initial alignment. Input to
<literal>align()</literal> consists of a set of unaligned sequences in the
form of the name of file containing the sequences or a reference to an
array of Seq objects. Typical syntax is shown below. (We illustrate with
Clustalw.pm, but the same syntax - except for the module name - would work
for TCoffee.pm)


</para>

<para>
<screen>
  use Bio::Tools::Run::Alignment::Clustalw;
  @params = ('ktuple' =&gt; 2, 'matrix' =&gt; 'BLOSUM');
  $factory = Bio::Tools::Run::Alignment::Clustalw-&gt;new(@params);
  $ktuple = 3;
  $factory-&gt;ktuple($ktuple);  # change the parameter before executing
  $seq_array_ref = \@seq_array;
      # where @seq_array is an array of Bio::Seq objects
  $aln = $factory-&gt;align($seq_array_ref);
</screen>


</para>

<para>
Clustalw.pm/TCoffee.pm can also align two (sub)alignments to each other or
add a sequence to a previously created alignment by using the profile_align
method. For further details on the required syntax and options for the
profile_align method, the user is referred to
<emphasis>Bio</emphasis> and
<emphasis>Bio</emphasis>. The user is also encouraged to examine the script clustalw.pl in the
examples/ directory.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-y"><title>III.5.4 Manipulating / displaying alignments (SimpleAlign)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
As described in section <emphasis>II.2</emphasis>, bioperl previously included two alignment objects, SimpleAlign and
UnivAln, but UnivAln.pm is not supported as of v. 1.0. SimpleAlign objects
are produced by bioperl alignment creation objects (eg Clustalw.pm, BLAST's
bl2seq, and pSW) and they can read and write multiple alignment formats via
AlignIO.


</para>

<para>
Some of the manipulations possible with SimpleALign include:


</para>

<itemizedList>
<listitem><para>
</para>

<para>
<literal>slice():</literal> Obtaining an alignment ``slice'', that is, a
subalignment inclusive of specified start and end columns. Sequences with
no residues in the slice are excluded from the new alignment and a warning
is printed.


</para>

</listitem>
<listitem><para>
</para>

<para>
<literal>column_from_residue_number():</literal> Finding column in an
alignment where a specified residue of a specified sequence is located.


</para>

</listitem>
<listitem><para>
</para>

<para>
<literal>consensus_string():</literal> Making a consensus string. This
method includes an optional threshold parameter, so that positions in the
alignment with lower percent-identity than the threshold are marked by
``?'''s in the consensus


</para>

</listitem>
<listitem><para>
</para>

<para>
<literal>percentage_identity():</literal> A fast method for calculating the
average percentage identity of the alignment


</para>

</listitem>
<listitem><para>
</para>

<para>
<literal>consensus_iupac():</literal> Making a consensus using IUPAC
ambiguity codes from DNA and RNA.


</para>

</listitem></itemizedList>

<para>
Skeleton code for using some of these features is shown below. More
detailed, working code is in Demo example 14 and in align_on_codons.pl in
the scripts directory. Additional documentation on methods can be found in
<emphasis>Bio</emphasis> and <emphasis>Bio</emphasis>.


</para>

<para>
<screen>
  use Bio::SimpleAlign;
  $aln = Bio::SimpleAlign-&gt;new('t/data/testaln.dna');
  $threshold_percent = 60;
  $consensus_with_threshold = $aln-&gt;consensus_string($threshold_percent);
  $iupac_consensus = $aln-&gt;consensus_iupac();   # dna/rna alignments only
  $percent_ident = $aln-&gt;percentage_identity;
  $seqname = '1433_LYCES';
  $pos = $aln-&gt;column_from_residue_number($seqname, 14);
</screen>


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-z"><title>III.6 Searching for genes and other structures on genomic DNA
(Genscan, Sim4, Grail, Genemark, ESTScan, MZEF, EPCR)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Automated searching for putative genes, coding sequences,
sequence-tagged-sites (STS's) and other functional units in genomic and
expressed sequence tag (EST) data has become very important as the
available quantity of sequence data has rapidly increased. Many feature
searching programs currently exist. Each produces reports containing
predictions that must be read manually or parsed by automated report
readers.


</para>

<para>
Parsers for six widely used gene prediction programs - Genscan, Sim4,
Genemark, Grail, ESTScan and MZEF - are currently available or under active
development in bioperl. The interfaces for the four parsers are similar. We
illustrate the usage for Genscan and Sim4 here. The syntax is relatively
self-explanatory; see <emphasis>Bio</emphasis>, <emphasis>Bio</emphasis>,
<emphasis>Bio</emphasis>, <emphasis>Bio</emphasis>, <emphasis>Bio</emphasis>, and
<emphasis>Bio</emphasis> for further details.


</para>

<para>
<screen>
  use Bio::Tools::Genscan;
  $genscan = Bio::Tools::Genscan-&gt;new(-file =&gt; 'result.genscan');
  # $gene is an instance of Bio::Tools::Prediction::Gene
  # $gene-&gt;exons() returns an array of Bio::Tools::Prediction::Exon objects
  while($gene = $genscan-&gt;next_prediction())
      { @exon_arr = $gene-&gt;exons(); }
  $genscan-&gt;close();
</screen>


</para>

<para>
See <emphasis>Bio</emphasis> and <emphasis>Bio</emphasis>
for more details.


</para>

<para>
<screen>
  use Bio::Tools::Sim4::Results;
  $sim4 = new Bio::Tools::Sim4::Results(-file =&gt; 't/data/sim4.rev',
                                        -estisfirst =&gt; 0);
  # $exonset is-a Bio::SeqFeature::Generic with Bio::Tools::Sim4::Exons
  # as sub features
  $exonset = $sim4-&gt;next_exonset;
  @exons = $exonset-&gt;sub_SeqFeature();
  # $exon is-a Bio::SeqFeature::FeaturePair
  $exon = 1;
  $exonstart = $exons[$exon]-&gt;start();
  $estname = $exons[$exon]-&gt;est_hit()-&gt;seqname();
  $sim4-&gt;close();
</screen>


</para>

<para>
See <emphasis>Bio</emphasis> and <emphasis>Bio</emphasis> for more information.


</para>

<para>
A parser for the ePCR program is also available. The ePCR program
identifies potential PCR-based sequence tagged sites (STSs) For more
details see the documentation in <emphasis>Bio</emphasis>. A sample skeleton script for parsing an ePCR report and using the data to
annotate a genomic sequence might look like this:


</para>

<para>
<screen>
  use Bio::Tools::EPCR;
  use Bio::SeqIO;
  $parser = new Bio::Tools::EPCR(-file =&gt; 'seq1.epcr');
  $seqio = new Bio::SeqIO(-format =&gt; 'fasta', -file =&gt; 'seq1.fa');
  $seq = $seqio-&gt;next_seq;
  while( $feat = $parser-&gt;next_feature ) {
        # add EPCR annotation to a sequence
        $seq-&gt;add_SeqFeature($feat);}
</screen>


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-aa"><title>III.7 Developing machine readable sequence annotations

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Historically, annotations for sequence data have been entered and read
manually in flat-file or relational databases with relatively little
concern for machine readability. More recent projects - such as EBI's
Ensembl project and the efforts to develop an XML molecular biology data
specification - have begun to address this limitation. Because of its
strengths in text processing and regular-expression handling, perl is a
natural choice for the computer language to be used for this task. And
bioperl offers numerous tools to facilitate this process - several of which
are described in the following sub-sections.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-ab"><title>III.7.1 Representing sequence annotations (Annotation,SeqFeature)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
As of the 0.7 release of bioperl, the fundamental sequence object, Seq, can
have multiple sequence feature (SeqFeature) objects - eg Gene, Exon,
Promoter objects - associated with it. A Seq object can also have an
Annotation object (used to store database links, literature references and
comments) associated with it. Creating a new SeqFeature and Annotation and
associating it with a Seq is accomplished with syntax like:


</para>

<para>
<screen>
  $feat = new Bio::SeqFeature::Generic('-start'   =&gt; 40,
                                       '-end'     =&gt; 80,
                                       '-strand'  =&gt; 1,
                                       '-primary' =&gt; 'exon',
                                       '-source'  =&gt; 'internal' );
  $seqobj-&gt;add_SeqFeature($feat); # Add the SeqFeature to the parent
  $seqobj-&gt;annotation(new Bio::Annotation
      ('-description' =&gt; 'desc-here'));
</screen>


</para>

<para>
Once the features and annotations have been associated with the Seq, they
can be with retrieved, eg:


</para>

<para>
<screen>
  @topfeatures = $seqobj-&gt;top_SeqFeatures(); # just top level, or
  @allfeatures = $seqobj-&gt;all_SeqFeatures(); # descend into sub features
  $ann = $seqobj-&gt;annotation(); # annotation object
</screen>


</para>

<para>
The individual components of a SeqFeature can also be set or retrieved with
methods including:


</para>

<para>
<screen>
  # attributes which return numbers
  $feat-&gt;start          # start position
  $feat-&gt;end            # end position
</screen>


</para>

<para>
<screen>
  $feat-&gt;strand         # 1 means forward, -1 reverse, 0 not relevant
</screen>


</para>

<para>
<screen>
  # attributes which return strings
  $feat-&gt;primary_tag    # the main 'name' of the sequence feature,
                        # eg, 'exon'
  $feat-&gt;source_tag     # where the feature comes from, eg'BLAST'
</screen>


</para>

<para>
<screen>
  # attributes which return Bio::PrimarySeq objects
  $feat-&gt;seq            # the sequence between start,end
  $feat-&gt;entire_seq     # the entire sequence
</screen>


</para>

<para>
<screen>
  # other useful methods include
  $feat-&gt;overlap($other)  # do SeqFeature $feat and SeqFeature $other overlap?
  $feat-&gt;contains($other) # is $other completely within $feat?
  $feat-&gt;equals($other)   # do $feat and $other completely agree?
  $feat-&gt;sub_SeqFeatures  # create/access an array of subsequence features
</screen>


</para>

<para>
See <emphasis>Bio</emphasis> and <emphasis>Bio</emphasis> as starting points for further exploration, and see the scripts/gff2ps.pl
script.


</para>

<para>
In general, storing and retrieving feature information should be
straightforward. However, one potential trap relates to features whose
location is either ``split'' - as in a multi-exon gene - or ``fuzzy'' - as
when genomic coordinates are not yet known with certainty. In these cases,
the SeqFeature objects need to be built with one of the alternate Location
objects described in Section <emphasis>II.3</emphasis>.


</para>

<para>
If more detailed annotation than available in Seq objects is required, the
RichSeq object may be used. It is applicable in particular to database
sequences (EMBL, GenBank and Swissprot) with detailed annotations. Sample
usage might be:


</para>

<para>
<screen>
    @secondary   = $richseq-&gt;get_secondary_accessions;
    $division    = $richseq-&gt;division;
    @dates       = $richseq-&gt;get_dates; 
    $seq_version = $richseq-&gt;seq_version;  
</screen>


</para>

<para>
See <emphasis>Bio</emphasis> for more details.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-ac"><title>III.7.2 Representing and large and/or changing sequences (LiveSeq,LargeSeq)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
This interface extends the Bio::SeqI interface to give additional
functionality to sequences with richer data sources, in particular from
database sequences (EMBL, GenBank and Swissprot).


</para>

<para>
Very large sequences and/or data files with sequences that are frequently
being updated present special problems to automated sequence-annotation
storage and retrieval projects. Bioperl's LargeSeq and LiveSeq objects are
designed to address these two situations.


</para>

<para>
LargeSeq


</para>

<para>
A LargeSeq object is a SeqI compliant object that stores a sequence as a
series of files in a temporary directory (see sect <emphasis>II.1</emphasis>
or <emphasis>Bio</emphasis> for a definition of SeqI objects). The aim is to enable storing very large
sequences (eg, &gt; 100MBases) without running out of memory and, at the same time, preserving
the familiar bioperl Seq object interface. As a result, from the users
perspective, using a LargeSeq object is almost identical to using a Seq
object. The principal difference is in the format used in the SeqIO calls.
Another difference is that the user must remember to only read in small
chunks of the sequence at one time. These differences are illustrated in
the following code:


</para>

<para>
<screen>
  $seqio = new Bio::SeqIO('-format'=&gt;'largefasta',
                          '-file'  =&gt;'t/data/genomic-seq.fasta');
  $pseq = $seqio-&gt;next_seq();
  $plength = $pseq-&gt;length();
  $last_4 = $pseq-&gt;subseq($plength-3,$plength);  # this is OK
</screen>


</para>

<para>
<screen>
  # On the other hand, the next statement would
  # probably cause the machine to run out of memory
  # $lots_of_data = $pseq-&gt;seq();  # NOT OK for a large LargeSeq object
</screen>


</para>

<para>
LiveSeq


</para>

<para>
The LiveSeq object addresses the need for a sequence object capable of
handling sequence data that may be changing over time. In such a sequence,
the precise locations of features along the sequence may change. LiveSeq
deals with this issue by re-implementing the sequence object internally as
a ``double linked chain.'' Each element of the chain is connected to other
two elements (the PREVious and the NEXT one). There is no absolute position
(like in an array), hence if positions are important, they need to be
computed (methods are provided). Otherwise it's easy to keep track of the
elements with their ``LABELs''. There is one LABEL (think of it as a
pointer) to each ELEMENT. The labels won't change after insertions or
deletions of the chain. So it's always possible to retrieve an element even
if the chain has been modified by successive insertions or deletions.


</para>

<para>
Although the implementation of the LiveSeq object is novel, its bioperl
user interface is unchanged since LiveSeq implements a PrimarySeqI
interface (recall PrimarySeq is the subset of Seq without annotations or
SeqFeatures - see section <emphasis>II.1</emphasis> or <emphasis>Bio</emphasis>). Consequently syntax for using LiveSeq objects is familiar although a
modified version of SeqIO called Bio::LiveSeq::IO::Bioperl needs to be used
to actually load the data, eg:


</para>

<para>
<screen>
  $loader=Bio::LiveSeq::IO::BioPerl-&gt;load('-db'=&gt;"EMBL",
                                          '-file'=&gt;"t/data/factor7.embl");
  $gene=$loader-&gt;gene2liveseq('-gene_name' =&gt; "factor7");
  $id = $gene-&gt;get_DNA-&gt;display_id ;
  $maxstart = $gene-&gt;maxtranscript-&gt;start;
</screen>


</para>

<para>
See <emphasis>Bio</emphasis> for more details.


</para>

<para>
Creating, maintaining and querying of LiveSeq genes is quite memory and
processor intensive. Consequently, any additional information relating to
mutational changes in a gene need to be stored separately from the sequence
data itself. The next section describes the mutation and polymorphism
objects used to accomplish this.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-ad"><title>III.7.3 Representing related sequences - mutations,
polymorphisms etc (Allele, SeqDiff)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
The Mutation object allows for a basic description of a sequence change in
the DNA sequence of a gene. The Mutator object takes in mutations, applies
them to a LiveSeq gene and returns a set of Bio::Variation objects
describing the net effect of the mutation on the gene at the DNA, RNA and
protein level.


</para>

<para>
The objects in Bio::Variation and Bio::LiveSeq directory were originally
designed for the ``Computational Mutation Expression Toolkit'' project at
European Bioinformatics Institute (EBI). The result of using them to mutate
a gene is a holder object, 'SeqDiff', that can be printed out or queried
for specific information. For example, to find out if restriction enzyme
changes caused by a mutation are exactly the same in DNA and RNA sequences,
we can write:


</para>

<para>
<screen>
  use Bio::LiveSeq::IO::BioPerl;
  use Bio::LiveSeq::Mutator;
  use Bio::LiveSeq::Mutation;
</screen>


</para>

<para>
<screen>
  $loader = Bio::LiveSeq::IO::BioPerl-&gt;load('-file' =&gt; "$filename");
  $gene = $loader-&gt;gene2liveseq('-gene_name' =&gt; $gene_name);
  $mutation = new Bio::LiveSeq::Mutation ('-seq' =&gt;'G',
                                          '-pos' =&gt; 100 );
  $mutate = Bio::LiveSeq::Mutator-&gt;new('-gene'      =&gt; $gene,
                                       '-numbering' =&gt; "coding"  );
  $mutate-&gt;add_Mutation($mutation);
  $seqdiff = $mutate-&gt;change_gene();
  $DNA_re_changes = $seqdiff-&gt;DNAMutation-&gt;restriction_changes;
  $RNA_re_changes = $seqdiff-&gt;RNAChange-&gt;restriction_changes;
  $DNA_re_changes eq $RNA_re_changes or print "Different!\n";
</screen>


</para>

<para>
For a complete working script, see the change_gene.pl script in the
examples directory. For more details on the use of these objects see <emphasis>Bio</emphasis> and <emphasis>Bio</emphasis> as well as the original documentation for the ``Computational Mutation
Expression Toolkit'' project at http://www.ebi.ac.uk/mutations/toolkit/.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-ae"><title>III.7.4 Incorpotating quality data in sequence annotation (SeqWithQuality)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
SeqWithQuality objects are used to describe sequences with very specific
annotations - that is, data quality annotaions. Data quality information is
important for documenting the reliability of base ``calls'' in newly
sequenced or otherwise questionable sequence data. The quality data is
contained within a Bio::Seq::PrimaryQual object. Syntax for using
SeqWithQuality objects is as follows:


</para>

<para>
<screen>
  # first, make a PrimarySeq object
  $seqobj = Bio::PrimarySeq-&gt;new
          ( -seq =&gt; 'atcgatcg',            -id  =&gt; 'GeneFragment-12',
            -accession_number =&gt; 'X78121', -alphabet =&gt; 'dna');
  # now make a PrimaryQual object
  $qualobj = Bio::Seq::PrimaryQual-&gt;new
         ( -qual =&gt; '10 20 30 40 50 50 20 10', -id  =&gt; 'GeneFragment-12',
           -accession_number =&gt; 'X78121',      -alphabet =&gt; 'dna');
  # now make the SeqWithQuality object
  $swqobj = Bio::Seq::SeqQithQuality-&gt;new
          ( -seq  =&gt; $seqobj, -qual =&gt; $qualobj);
  # Now we access the sequence with quality object
  $swqobj-&gt;id(); # the id of the SeqWithQuality object may not match the
                 # id of the sequence or of the quality
  $swqobj-&gt;seq(); # the sequence of the SeqWithQuality object
  $swqobj-&gt;qual(); # the quality of the SeqWithQuality object
</screen>


</para>

<para>
A SeqWithQuality object is created automatically when phred output, a
<literal>*phd</literal> file, is read by Seqio, eg


</para>

<para>
<screen>
  $seqio = Bio::SeqIO-&gt;new(-file=&gt;"my.phd",-format=&gt;"phd");
  # or just 'Bio::SeqIO-&gt;new(-file=&gt;"my.phd")'
  $seqWithQualObj = $seqio-&gt;next_seq;
</screen>


</para>

<para>
See <emphasis>Bio</emphasis> for a detailed description of the methods,
<emphasis>Bio</emphasis>, and <emphasis>Bio</emphasis>.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-af"><title>III.7.5 Sequence XML representations - generation and parsing (SeqIO::game, SeqIO::bsml)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
The previous subsections have described tools for automated sequence
annotation by the creation of an ``object layer'' on top of a traditional
database structure. XML takes a somewhat different approach. In XML, the
data structure is unmodified, but machine readability is facilitated by
using a data-record syntax with special flags and controlled vocabulary.


</para>

<para>
Bioperl supports a set of XML flags and vocabulary words for molecular
biology - called bioxml - detailed at http://www.bioxml.org/dtds/current/.
The idea is that any bioxml features can be turned into bioperl Seq
annotations. Conversely Seq object features and annotations can be
converted to XML so that they become available to any other systems that
are XML (and bioxml) compliant. Typical usage is shown below. No special
syntax is required by the user. Note that some Seq annotation will be lost
when using bioxml in this manner since in its current implementation bioxml
does not support all the annotation information available in Seq objects.


</para>

<para>
<screen>
  $str = Bio::SeqIO-&gt;new('-file'=&gt; 't/data/test.game',
                         '-format' =&gt; 'game');
  $seq = $str-&gt;next_primary_seq();
  $id = $seq-&gt;id;
  @feats = $seq-&gt;all_SeqFeatures();
  $first_primary_tag = $feats[0]-&gt;primary_tag;
</screen>


</para>

<para>
Additional XML formats to describe sequences and their annotations have
been created. BSML and AGAVE are two additional formats that have been
created in the last year. Bioperl currently only supports BSML through the
SeqIO system at this time. Usage is similar to other SeqIO parsing.


</para>

<para>
<screen>
  $str = Bio::SeqIO-&gt;new('-file'=&gt; 'bsmlfile.xml',
                         '-format' =&gt; 'bsml');
  $seq = $str-&gt;next_primary_seq();
  $id = $seq-&gt;id;
  @feats = $seq-&gt;all_SeqFeatures();
  $first_primary_tag = $feats[0]-&gt;primary_tag;
</screen>


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-ag"><title>III.8 Representing non-sequence data in Bioperl: structures, trees and maps

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Though bioperl has its roots in describing and searching nucleotide and
protein sequences it has also branched out into related fields of study,
such as protein structure, phylogenetic trees and genetic maps.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-ah"><title>III.8.1 Using 3D structure objects and reading PDB files
(StructureI, Structure::IO)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
A StructureIO object can be created from one or more 3D structures
represented in Protein Data Bank, or pdb, format (see
http://www.rcsb.org/pdb for details).


</para>

<para>
StructureIO objects allow access to a variety of related Bio:Structure
objects. An Entry object consist of one or more Model objects, which in
turn consist of one or more Chain objects. A Chain is composed of Residue
objects, which in turn consist of Atom objects. There's a wealth of
methods, here are just a few:


</para>

<para>
<screen>
  $structio = Bio::Structure::IO-&gt;new( -file =&gt; "1XYZ.pdb");
  $struc = $structio-&gt;next_structure; # returns an Entry object
  $ann = $struc-&gt;annotation; # returns a Bio::Annotation object
  $pseq = $struc-&gt;seqres;    # returns a PrimarySeq object, thus
  $pseq-&gt;subseq(1,20);              # returns a sequence string
  @atoms = $struc-&gt;get_atoms($res); # Atom objects, given a Residue
  @xyz = $atom-&gt;xyz;                # the 3D coordinates of the atom
</screen>


</para>

<para>
These lines show how one has access to a number of related objects and
methods. For examples of typical usage of these modules, see the scripts in
the examples/structure subdirectory. Also see <emphasis>Bio</emphasis>, 
<emphasis>Bio</emphasis>, <emphasis>Bio</emphasis>,
<emphasis>Bio</emphasis>, <emphasis>Bio</emphasis>, and
<emphasis>Bio</emphasis> for more information.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-ai"><title>III.8.2 Tree objects and phylogenetic trees (Tree::Tree, TreeIO)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Bioperl Tree objects can store data for all kinds of computer trees and are
intended especially for phylogenetic trees. Nodes and branches of trees can
be individually manipulated. The TreeIO object is used for stream I/O of
tree objects. Currently only phylip/newick tree format is supported. Sample
code might be:


</para>

<para>
<screen>
  $treeio = new Bio::TreeIO( -format =&gt; 'newick', -file   =&gt; $treefile);
  $tree = $treeio-&gt;next_tree;   # get the tree
  @nodes = $tree-&gt;get_nodes;    # get all the nodes
  $tree-&gt;get_root_node()-&gt;each_Descendent();  # get descendents of root node
</screen>


</para>

<para>
See <emphasis>Bio</emphasis> and <emphasis>Bio</emphasis> for details.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-aj"><title>III.8.3 Map objects for manipulating genetic maps (Map::MapI,
MapIO)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Bioperl map objects can be used to describe any type of biological map data
including genetic maps, STS maps etc. Map I/O is performed with the MapIO
object which works in a similar manner to the SeqIO, SearchIO and similar
I/O objects described previously. In principle, Map I/O with various map
data formats can be performed. However currently only ``mapmaker'' format
is supported. Manipulation of genetic map data with Bioperl Map objects
might look like this:


</para>

<para>
<screen>
  $mapio = new Bio::MapIO( '-format' =&gt; 'mapmaker', '-file' =&gt; $mapfile);
  $map = $mapio-&gt;next_map;  # get a map
  $maptype =  $map-&gt;type ;
  foreach  $marker ( $map-&gt;each_element ) {
    $marker_name =  $marker-&gt;name ;  # get the name of each map marker
  }
</screen>


</para>

<para>
See <emphasis>Bio</emphasis> and <emphasis>Bio</emphasis> for more information.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-ak"><title>III.8.4 Bibliographic objects for querying bibliographic databases (Biblio)

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Bio::Biblio objects are used to query bibliographic databases, such as
MEDLINE. The associated modules are built to work with OpenBQS-compatible
databases (see http://industry.ebi.ac.uk/openBQS). A Bio::Biblio object can
execute a query like:


</para>

<para>
<screen>
  my $collection = $biblio-&gt;find ('brazma', 'authors');
  while ( $collection-&gt;has_next ) {
      print $collection-&gt;get_next;
  }
</screen>


</para>

<para>
See <emphasis>Bio</emphasis> or the examples/biblio.pl script for details.


</para>

<para>
III.8.5 Graphics objects for representing sequence objects as images
(Graphics)


</para>

<para>
A user may want to represent Seq objects and their SeqFeatures graphically.
The Bio::Graphics::* modules use Perl's GD.pm module to create a PNG or GIF
image given the SeqFeatures (Section <emphasis>III.7.1</emphasis>) contained within a Seq object.


</para>

<para>
These modules contain numerous methods to dictate the sizes, colors,
labels, and line formats within the image. See <emphasis>Bio</emphasis>, <emphasis>Bio</emphasis>, or the scripts/render_sequence.pl script for more information.


</para>

<para>
The Genquire application also provides ways to graphically represent Seq
objects (see Section <emphasis>IV.6</emphasis>).


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-al"><title>III.9 Bioperl alphabets

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Bioperl modules use the standard extended single-letter genetic alphabets
to represent nucleotide and amino acid sequences.


</para>

<para>
In addition to the standard alphabet, the following symbols are also
acceptable in a biosequence:


</para>

<para>
<screen>
 ?  (a missing nucleotide or amino acid)
 -  (gap in sequence)
</screen>


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-am"><title>III.9.1 Extended DNA / RNA alphabet

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
<screen>
 (includes symbols for nucleotide ambiguity)
 ------------------------------------------
 Symbol       Meaning      Nucleic Acid
 ------------------------------------------
  A            A           Adenine
  C            C           Cytosine
  G            G           Guanine
  T            T           Thymine
  U            U           Uracil
  M          A or C
  R          A or G
  W          A or T
  S          C or G
  Y          C or T
  K          G or T
  V        A or C or G
  H        A or C or T
  D        A or G or T
  B        C or G or T
  X      G or A or T or C
  N      G or A or T or C
</screen>


</para>

<para>
<screen>
 IUPAC-IUB SYMBOLS FOR NUCLEOTIDE NOMENCLATURE:
   Cornish-Bowden (1985) Nucl. Acids Res. 13: 3021-3030.
</screen>


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-5-an"><title>III.9.2 Amino Acid alphabet

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
<screen>
 ------------------------------------------
 Symbol   Meaning
 ------------------------------------------
 A        Alanine
 B        Aspartic Acid, Asparagine
 C        Cystine
 D        Aspartic Acid
 E        Glutamic Acid
 F        Phenylalanine
 G        Glycine
 H        Histidine
 I        Isoleucine
 K        Lysine
 L        Leucine
 M        Methionine
 N        Asparagine
 P        Proline
 Q        Glutamine
 R        Arginine
 S        Serine
 T        Threonine
 V        Valine
 W        Tryptophan
 X        Unknown
 Y        Tyrosine
 Z        Glutamic Acid, Glutamine
 *        Terminator
</screen>


</para>

<para>
<screen>
   IUPAC-IUP AMINO ACID SYMBOLS:
   Biochem J. 1984 Apr 15; 219(2): 345-373
   Eur J Biochem. 1993 Apr 1; 213(1): 2
</screen>


</para>

</sect2>

</sect1>

<sect1 id="pod2docbook-ch-1-sect-6"><title>IV.  Related projects - biocorba, biopython, biojava, Ensembl,
 Genquire /AnnotationWorkbench / bioperl-gui

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
There are several ``sister projects'' to bioperl currently under
development. These include biocorba, biopython, biojava, EMBOSS, Ensembl,
and Genquire / Annotation Workbench (which includes Bioperl-gui). These are
all large complex projects and describing them in detail here will not be
attempted. However a brief introduction seems appropriate since, in the
future, they may each provide significant added utility to the bioperl
user.


</para>

<sect2 id="pod2docbook-ch-1-sect-6-a"><title>IV.1 Biocorba

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Interface objects have facilitated interoperability between bioperl and
other perl packages such as Ensembl and the Annotation Workbench. However,
interoperability between bioperl and packages written in other languages
requires additional support software. CORBA is one such framework for
interlanguage support, and the biocorba project is currently implementing a
CORBA interface for bioperl. With biocorba, objects written within bioperl
will be able to communicate with objects written in biopython and biojava
(see the next subsection). For more information, see the biocorba project
website at http://biocorba.org/. The Bioperl BioCORBA server and client
bindings are available in the bioperl-corba-server and bioperl-corba-client
bioperl CVS repositories respecitively. (see http://cvs.bioperl.org for
more information). 


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-6-b"><title>IV.2 Biopython and biojava

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Biopython and biojava are open source projects with very similar goals to
bioperl. However their code is implemented in python and java,
respectively. With the development of interface objects and biocorba, it is
possible to write java or python objects which can be accessed by a bioperl
script, or to call bioperl objects from java or python code. Since
biopython and biojava are more recent projects than bioperl, most effort to
date has been to port bioperl functionality to biopython and biojava rather
than the other way around. However, in the future, some bioinformatics
tasks may prove to be more effectively implemented in java or python in
which case being able to call them from within bioperl will become more
important. For more information, go to the biojava http://biojava.org/ and
biopython http://biopython.org/ websites.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-6-c"><title>IV.3 EMBOSS

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
EMBOSS is another open source project with similar goals to bioperl.
However EMBOSS code is implemented in C and has been designed for
standalone execution on the Unix command line, rather than for
incorporation into a user script or program. EMBOSS includes a wide array
of useful bioinformatics functions similar to those of the GCG package
after which it was designed. A bioperl interface to the EMBOSS functions
has been partially completed. When this interface is complete, it will be
possible to access EMBOSS functions as though they were bioperl objects (in
a manner similar to how the StandAloneBlast bioperl module enables access
to performing Blast searches within bioperl). For more information on
EMBOSS, refer to http://www.hgmp.mrc.ac.uk/Software/EMBOSS/. The principal
bioperl interface object to EMBOSS is described in
<emphasis>Bio</emphasis>.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-6-d"><title>IV.4  Ensembl and bioperl-db

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
Ensembl is an ambitious automated-genome-annotation project at EBI. Much of
Ensembl's code is based on bioperl, and Ensembl developers, in turn, have
contributed significant pieces of code to bioperl. In particular, the
bioperl code for automated sequence annotation has been largely contributed
by Ensembl developers. Describing Ensembl and its capabilities is far
beyond the scope of this tutorial The interested reader is referred to the
Ensembl website at http://www.ensembl.org/.


</para>

<para>
Bioperl-db is a relatively new project intended to transfer some of
Ensembl's capability of integrating bioperl syntax with a standalone Mysql
database (http://www.mysql.com) to the bioperl code-base. More details on
bioperl-db can be found in the bioperl-db CVS directory at
http://cvs.bioperl.org/cgi-bin/viewcvs/viewcvs.cgi/bioperl-db/?cvsroot=bioperl.
It is worth mentioning that most of the bioperl objects mentioned above map
directly to tables in the bioperl-db schema. Therefore object data such as
sequences, their features, and annotations can be easily loaded into the
databases, as in


</para>

<para>
<screen>
  $loader-&gt;store($newid,$seqobj)
</screen>


</para>

<para>
Similarly one can query the database in a variety of ways and retrieve
arrays of Seq objects. See biodatabases.pod, <emphasis>Bio</emphasis>,
<emphasis>Bio</emphasis>, and <emphasis>Bio</emphasis> for examples.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-6-e"><title>IV.5 GFF format and Bio::DB::GFF*

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
The Bio::DB::GFF module provides access to relational databases constructed
from data files in GFF format. This file type is well suited to sequence
annotation because it allows the ability to describe entries in terms of
parent-child relationships (see http://www.sanger.ac.uk/software/GFF for
details). Like bioperl-db, above, the current implementation uses mysql
(http://www.mysql.com).


</para>

<para>
The module accesses not only by id but by annotation type and position or
range. Those who would like to explore bioperl as a means to overlay
nucleotide sequence, protein sequence, features, and annotations should
take a close look at <emphasis>Bio</emphasis>and the load_gff.pl, bulk_load_gff.pl, gadfly_to_gff.pl, and sgd_to_gff.pl
scripts in the scripts/Bio-DB-GFF directory.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-6-f"><title>IV.6 Genquire, the Annotation Workbench and bioperl-gui

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
The Annotation Workbench and Genquire were developed at the Plant
Biotechnology Institute of the National Research Council of Canada. This is
an integrated graphical suite of tools in Perl for examining a sequence,
predicting gene structure, and creating annotations. Information about
Genquire is available at http://bioinformatics.org/project/?group_id=99.
With Genquire and bioperl-gui one can display a Bioperl Seq object
graphically. You can download the current version of the gui software from
the bioperl-gui CVS directory at
http://cvs.bioperl.org/cgi-bin/viewcvs/viewcvs.cgi/bioperl-gui/?cvsroot=bioperl.
You will also need Tcl/Tk.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-6-g"><title>V.1 Appendix: Finding out which methods are used by which
Bioperl Objects

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
At numerous places in the tutorial, the reader is directed to the
``documentation included with each of the modules.'' As was mentioned in
the introduction, it is sometimes not easy in perl to determine the
appropriate documentation to look for, because objects inherit methods from
other objects (and the relevant documentation will be stored in the object
from which the method was inherited.)


</para>

<para>
For example, say you wanted to find documentation on the ``parse'' method
of the object Genscan.pm. You would not find this documentation in the code
for Genscan.pm, but rather in the code for AnalysisResult.pm from which
Genscan.pm inherits the parse method!


</para>

<para>
So how would you know to look in AnalysisResult.pm for this documentation?
The easy way is to use the special function ``option 100'' in the
bptutorial script. Specifically if you run:


</para>

<para>
<screen>
 &gt; perl -w bptutorial.pl 100 Bio::Tools::Genscan
</screen>


</para>

<para>
you will receive the following output:


</para>

<para>
<screen>
 ***Methods for Object Bio::Tools::Genscan ********
</screen>


</para>

<para>
<screen>
 Methods taken from package Bio::Root::IO
 catfile   close   gensym   new   qualify   qualify_to_ref
 rmtree   tempdir   tempfile   ungensym
</screen>


</para>

<para>
<screen>
 Methods taken from package Bio::Root::RootI
 DESTROY   stack_trace   stack_trace_dump   throw   verbose   warn
</screen>


</para>

<para>
<screen>
 Methods taken from package Bio::SeqAnalysisParserI
 carp   confess   croak   next_feature
</screen>


</para>

<para>
<screen>
 Methods taken from package Bio::Tools::AnalysisResult
 analysis_date   analysis_method   analysis_method_version   analysis_query   analysis_subject   parse
</screen>


</para>

<para>
<screen>
 Methods taken from package Bio::Tools::Genscan
 next_prediction
</screen>


</para>

<para>
From this output, it is clear exactly from which object each method of
Genscan.pm is taken, and, in particular that ``parse'' is taken from the
package Bio::Tools::AnalysisResult.


</para>

<para>
With this approach you can easily determine the source of any method in any
bioperl object.


</para>

</sect2>

<sect2 id="pod2docbook-ch-1-sect-6-h"><title>V.2 Appendix: Tutorial demo scripts

</title>
<!-- Bogus hack to ensure that each sect has a paragraph in it -->
<para>
</para>


<para>
The following scripts demonstrate many of the features of bioperl. To run
all the demos run:


</para>

<para>
<screen>
 &gt; perl -w  bptutorial.pl 0
</screen>


</para>

<para>
To run a subset of the scripts do


</para>

<para>
<screen>
 &gt; perl -w  bptutorial.pl
</screen>


</para>

<para>
and use the displayed help screen.


</para>

</sect2>

</sect1>

</chapter>


</book>    <!-- End of the book -->
